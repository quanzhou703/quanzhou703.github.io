<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java高级技术</title>
      <link href="/posts/1c00/"/>
      <url>/posts/1c00/</url>
      
        <content type="html"><![CDATA[<h2 id="Java高级技术"><a href="#Java高级技术" class="headerlink" title="Java高级技术"></a>Java高级技术</h2><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><ul><li>可以用来对方法进行测试，它是第三方公司开源出来的。</li><li>可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成全部方法的自动化测试，且各自独立。</li><li>不需要程序员分析测试的结果，会自动生成测试报告。</li></ul><p>具体步骤：</p><ul><li>导入jar包（IDEA已集成，不需要导入）</li><li>为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须：公共、无参、无返回值）。</li><li>测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试。</li><li>开始测试：选中测试方法，右键选择“junit运行”，如果测试通过则是绿色，测试失败则是红色。</li></ul><img src="/posts/null/Junit%E6%B3%A8%E8%A7%A3.png" class="" title="Junit注解"><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li>反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）。</li><li>加载类，获取类的字节码：Class对象</li><li>获取类的构造器：Constructor对象</li><li>获取类的成员变量：Field对象</li><li>获取类的成员方法：Method对象</li></ul><h4 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.类名.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> 类名.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调用Class提供方法,className要带包名。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(String className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Object提供方法getClass()</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> student.getClass();</span><br></pre></td></tr></table></figure><h4 id="获取类的构造器"><a href="#获取类的构造器" class="headerlink" title="获取类的构造器"></a>获取类的构造器</h4><img src="/posts/null/%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8.png" class=""><img src="/posts/null/%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8.png" class=""><h4 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h4><img src="/posts/null/%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" class=""><img src="/posts/null/%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8.png" class=""><h4 id="获取类的成员方法"><a href="#获取类的成员方法" class="headerlink" title="获取类的成员方法"></a>获取类的成员方法</h4><img src="/posts/null/%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png" class=""><img src="/posts/null/%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8.png" class=""><h4 id="反射的作用和应用场景"><a href="#反射的作用和应用场景" class="headerlink" title="反射的作用和应用场景"></a>反射的作用和应用场景</h4><ul><li>基本作用：可以得到一个类的全部成分然后操作。</li><li>可以破坏封装性。</li><li><strong>适合做Java框架，基本上主流框架都会基于反射设计出一些通用的功能</strong></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li>java代码中的特殊标记，比如：@Override、@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序。（其他程序通过反射获取到注解，根据注解来决定执行程序）</li><li>注解可以用在类上、构造器上、方法上、成员变量上、参数上等位置处。</li></ul><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    <span class="keyword">public</span> 属性类型 属性名() defalut 默认值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest1&#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">bbb</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">    String[] ccc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/null/%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86.png" class=""><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li>修饰注解的注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/null/%E5%85%83%E6%B3%A8%E8%A7%A3.png" class=""><h4 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h4><ul><li>判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来。</li></ul><img src="/posts/null/%E8%A7%A3%E6%9E%90%E6%B3%A8%E8%A7%A3.png" class=""><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>程序为什么需要代理？代理长什么样？</p><ul><li>对象如果觉得身上的活太多，可以通过代理来转移部分职责。</li><li>对象有什么方法想被代理，代理一定要有对应的方法。</li></ul><img src="/posts/null/%E4%BB%A3%E7%90%86.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要找代理的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigStar</span> <span class="keyword">implements</span> <span class="title class_">Star</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigStar</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sing</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在唱：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;谢谢！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在跳舞...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定代理需要有哪些功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    String <span class="title function_">sing</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理公司，用于生产代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line">        <span class="comment">/*newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                InvocationHandler h*/</span></span><br><span class="line">        <span class="comment">//参数1：用于指定一个类加载器，加载代理类</span></span><br><span class="line">        <span class="comment">//参数2：指定接口，也就是生成的代理应该有哪些方法</span></span><br><span class="line">        <span class="comment">//参数3：用来指定生成的代理对象要干什么事情</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span>  (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">//回调方法</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//代理对象要做的事情，会在这里写代码</span></span><br><span class="line">                        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;sing&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒，收钱20W&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;dance&quot;</span>)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备场地，收钱1000W&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> starProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主类，为需要被代理的对象创建代理，使用代理调用方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigStar</span> <span class="variable">bigStar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStar</span>(<span class="string">&quot;杨超越&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span> ProxyUtil.createProxy(bigStar);</span><br><span class="line"></span><br><span class="line">        System.out.println(starProxy.sing(<span class="string">&quot;好日子&quot;</span>));<span class="comment">//调用invoke</span></span><br><span class="line"></span><br><span class="line">        starProxy.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/posts/cd50/"/>
      <url>/posts/cd50/</url>
      
        <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="基本通信架构"><a href="#基本通信架构" class="headerlink" title="基本通信架构"></a>基本通信架构</h3><ul><li>CS架构（客户端&#x2F;服务端）</li><li>BS架构（浏览器&#x2F;服务端）</li></ul><h3 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h3><p>IP地址、端口号、协议。</p><h4 id="IP地址（InetAddress）"><a href="#IP地址（InetAddress）" class="headerlink" title="IP地址（InetAddress）"></a>IP地址（InetAddress）</h4><ul><li><p>代表IP地址。</p><img src="/posts/cd50/image-20240702163832409.png" class="" title="image-20240702163832409"></li></ul><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><ul><li>标记正在计算机设备上运行的应用程序，被规定为一个16位的二进制，范围是0~65535。</li><li>周知端口：0~1024，被预先定义的知名应用占用（HTTP占用80，FTP占用21）</li><li><strong>注册端口</strong>：1024~49151，分配给用户进程或者某些应用程序。</li></ul><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li>网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络传输协议。</li></ul><h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5><p>特点：无连接、不可靠通信。通信效率高。如语音通话、视频直播。</p><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>特点：面向连接、可靠通信。在不可靠的信道上实现可靠传输。如文件下载。</p><p>三个步骤实现可靠传输：三次握手建立连接，传输数据进行确认，四次挥手断开连接。</p><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p>使用DatagramSocket进行通信。DatagramPacket包装数据。</p><img src="/posts/cd50/DatagramSocket.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1.创建客户端对象</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建数据包对象封装要发出去的数据</span></span><br><span class="line">    <span class="comment">/*public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">        InetAddress address, int port)</span></span><br><span class="line"><span class="comment">            参数一：封装要发出去的数据</span></span><br><span class="line"><span class="comment">            参数二：发送出去的数据的大小（字节个数）</span></span><br><span class="line"><span class="comment">            参数三：服务端IP地址</span></span><br><span class="line"><span class="comment">            参数四：服务端程序端口号</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请说：(exit退出)&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦发现用户输入exit命令，就退出客户端</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎下次光临！&quot;</span>);</span><br><span class="line">            socket.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,</span><br><span class="line">                                               InetAddress.getLocalHost(),<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.开始正式发送这个数据包出去</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---服务端启动---&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个服务端对象,注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建一个数据包对象，用于接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">//64KB</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">            socket.receive(dp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">            <span class="comment">// 读取多少，倒出多少</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,dp.getLength());</span><br><span class="line">            System.out.println(dp.getAddress().getHostAddress()+</span><br><span class="line">                    <span class="string">&quot;：&quot;</span>+dp.getPort()+<span class="string">&quot;发送数据：&quot;</span>+rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><p>客户端使用Socket进行通信。</p><p>服务端使用ServerSocket进行通信。</p><img src="/posts/cd50/TCP%E5%AE%A2%E6%88%B7%E7%AB%AFAPI.png" class=""><img src="/posts/cd50/TCP%E6%9C%8D%E5%8A%A1%E7%AB%AFAPI.png" class=""><h4 id="客户端服务端"><a href="#客户端服务端" class="headerlink" title="客户端&lt;-&gt;服务端"></a>客户端&lt;-&gt;服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.创建Socket对象，并同时请求与服务端程序的连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//4.开始写数据出去</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请说（exit退出）&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一旦用户输入exit，退出客户端</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(msg))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;退出程序&quot;</span>);</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动成功~~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，同时注册端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用ServerSocket调用accept方法，等待客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从socket通信管道中得到一个字节输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.使用数据输入流读取客户端发送的数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()</span><br><span class="line">                        + <span class="string">&quot;：&quot;</span> + rs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(socket.getRemoteSocketAddress()+<span class="string">&quot;离线了&quot;</span>);</span><br><span class="line">                dis.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多客户端服务端"><a href="#多客户端服务端" class="headerlink" title="多客户端&lt;-&gt;服务端"></a>多客户端&lt;-&gt;服务端</h4><img src="/posts/cd50/TCP%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1.png" class=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎进入系统，请说（exit退出）&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建与服务端的连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.从socket管道获取输出流并包装成数据输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">ds</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(ds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.往管道中发送数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (msg.equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;退出系统&quot;</span>);</span><br><span class="line">                dos.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dos.writeUTF(msg);</span><br><span class="line">            dos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建服务端socket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//2.接收客户端连接，分配子线程来处理</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReadThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReadThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//读取客户端消息</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress()+<span class="string">&quot;：&quot;</span>+socket.getPort()+<span class="string">&quot;说：&quot;</span>+dis.readUTF());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(socket.getRemoteSocketAddress()+<span class="string">&quot;离线了&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h4><img src="/posts/cd50/%E7%BE%A4%E8%81%8A.png" class=""><p><strong>注意：</strong></p><ul><li>每个客户端也要开启子线程用于读取服务端转发的消息。</li><li>客户端离线，服务端会报异常，要做对应的处理（关闭流，关闭socket，删除集合中对应的socket）。</li></ul><h4 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B&#x2F;S架构"></a>B&#x2F;S架构</h4><p>只需要开发服务端就可以了。</p><img src="/posts/cd50/B-S%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.png" class=""><img src="/posts/cd50/HTTP%E9%80%9A%E4%BF%A1%E6%A0%BC%E5%BC%8F.png" class="">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/5ea3/"/>
      <url>/posts/5ea3/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>多线程是指从软硬件上实现多条执行流程的技术（多条线程由CPU负责调度执行）。</li></ul><h3 id="线程创建一：继承Thread"><a href="#线程创建一：继承Thread" class="headerlink" title="线程创建一：继承Thread"></a>线程创建一：继承Thread</h3><ol><li>让子类继承Thread</li><li>重写Thread类的run方法</li><li>创建子类对象，start()启动线程</li></ol><p><strong>注意：</strong></p><ul><li>不要手动调用run方法，不然相当于在main线程中调用普通的方法，不会开启一个子线程去执行。</li><li>不要把主线程的任务放在子线程之前，不然会先执行完主线程完毕才会执行子线程任务。</li></ul><h3 id="线程创建二：实现Runnable接口"><a href="#线程创建二：实现Runnable接口" class="headerlink" title="线程创建二：实现Runnable接口"></a>线程创建二：实现Runnable接口</h3><ol><li>定义一个任务类实现Runnable接口</li><li>重写Runnable接口的run方法</li><li>创建任务对象，交给线程对象处理。</li><li>调用线程的start方法启动线程。</li></ol><h3 id="线程创建三：实现Callable接口"><a href="#线程创建三：实现Callable接口" class="headerlink" title="线程创建三：实现Callable接口"></a>线程创建三：实现Callable接口</h3><ul><li>假如线程执行完毕后有一些数据需要返回，方式一和方式二重写的run方法均不能返回结果。</li><li>JDK5.0提供了Callable接口和FutureTask类来实现（第三种方式）。</li></ul><ol><li>实现Callable接口，重写call方法，封装要做的事和要返回的数据。</li><li>把Callable类型的对象封装成FutureTask（线程任务对象）。</li><li>把线程任务对象交给Thread对象。</li><li>调用Thread类的start方法启动线程。</li><li>线程执行完毕后，通过FutureTask对象的get方法去获取线程任务执行的结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1-&quot;</span>+ n + <span class="string">&quot;求和结果为：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">    FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(f1).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(f1.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程main输出：&quot;</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run();<span class="comment">//线程的任务方法</span></span><br><span class="line">start();<span class="comment">//启动线程</span></span><br><span class="line">getName();<span class="comment">//获取当前线程的名称，默认是Thread-索引</span></span><br><span class="line">setName(String name);<span class="comment">//为线程设置名称</span></span><br><span class="line">currentThread();<span class="comment">//获取当前执行的线程对象</span></span><br><span class="line">sleep(<span class="type">long</span> time);<span class="comment">//让当前执行的线程休眠xx毫秒</span></span><br><span class="line">join();<span class="comment">//让调用这个方法的线程先执行完（插队）</span></span><br></pre></td></tr></table></figure><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><ul><li>多个线程，同时操作一个共享资源的时候，可能会出现线程安全问题。</li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li>解决线程安全问题的方案。</li><li>让多个线程实现先后依次访问共享资源。</li><li>加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来。</li></ul><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>把访问共享资源的核心代码给上锁，以此保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    核心代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于当前同时执行的线程，同步锁必须是同一把（同一个对象，唯一），否则会出bug。</span></span><br><span class="line">一般建议使用共享资源作为锁对象。实例方法<span class="built_in">this</span>对象作为锁，静态方法的话使用类名.class作为锁。</span><br></pre></td></tr></table></figure><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>把访问共享资源的核心方法上锁，以此保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名称（形参列表）&#123;</span><br><span class="line">    操作共享资源的代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步方法其实底层也是有隐式锁，与同步代码块一致。</span></span><br></pre></td></tr></table></figure><p><strong>对比：同步代码块锁的范围小一些，性能好一些。</strong></p><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><ul><li>Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建锁对象加锁和解锁，更灵活、方便、强大。</li><li>Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。</li></ul><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul><li>当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺。</li></ul><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><ul><li>生产者线程负责生产数据。</li><li>消费者线程负责消费生产者生产的数据。</li><li>生产者生产完数据应该等待自己，通知消费者消费；消费者消费完数据也应该等待自己，再通知生产者生产。</li></ul><h4 id="线程通信模型案例"><a href="#线程通信模型案例" class="headerlink" title="线程通信模型案例"></a>线程通信模型案例</h4><img src="/posts/5ea3/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-1719907916944.png" class="" title="多线程-线程通信"><img src="/posts/5ea3/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92-1719907934927.png" class="" title="多线程-等待唤醒"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享资源桌子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放一个包子 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子</span></span><br><span class="line">            <span class="keyword">if</span> (list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的一个肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做的一个肉包子&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//等待自己，唤醒别人</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//有包子，不做了</span></span><br><span class="line">                <span class="comment">//唤醒别人，自己睡觉</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取包子 吃货1 吃货2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//有包子，吃掉</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;吃了：&quot;</span>+list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有包子</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCommunicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建3个生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;厨师1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;厨师2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;厨师3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建2个消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;吃货1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;吃货2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ea3/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B-1719907961435.png" class="" title="多线程-线程通信模型"><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程来处理，而创建新线程的开销是很大的，并且会产生大量的线程出来，这样会严重影响系统的性能。</li><li>线程池就是一个可以复用线程的技术。</li></ul><h4 id="ThreadPoolExecutor创建线程池"><a href="#ThreadPoolExecutor创建线程池" class="headerlink" title="ThreadPoolExecutor创建线程池"></a>ThreadPoolExecutor创建线程池</h4><ul><li><p>JDK5提供了代表线程池的接口：ExecutorService，使用其实现类ThreadPoolExecutor创建线程池对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectExecutionHandler handler)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数一：corePoolSize：指定线程池的核心线程的数量。长久可以复用。</span></span><br><span class="line"><span class="comment">//参数二：maximumPoolSize：指定线程池的最大线程数量。大于核心线程的数量，多出来的是临时线程。</span></span><br><span class="line"><span class="comment">//参数三：keepAliveTime：指定临时线程的存活时间。</span></span><br><span class="line"><span class="comment">//参数四：unit：指定临时线程存活的时间单位（秒、分、时、天）。</span></span><br><span class="line"><span class="comment">//参数五：workQueue：指定线程池的任务队列。</span></span><br><span class="line"><span class="comment">//参数六：threadFactory：指定线程池的线程工厂（用来创建线程的）。</span></span><br><span class="line"><span class="comment">//参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满的时候，新任务来了该怎么处理）。</span></span><br><span class="line">    </span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure></li><li><p>使用Executors（线程池工具类）调用方法返回不同特点的线程池对象。</p></li></ul><h5 id="线程池处理Runnable任务"><a href="#线程池处理Runnable任务" class="headerlink" title="线程池处理Runnable任务"></a>线程池处理Runnable任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>; <span class="comment">//执行Runnable任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;<span class="comment">//关掉线程池（等待任务执行完毕后）</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;<span class="comment">//立即关掉线程池，返回没有执行完的任务列表。</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p>临时线程什么时候创建？</p><ul><li>新任务提交时发现核心线程都在忙，任务队列也满了（正在执行的不属于任务队列，排队没执行的才是任务队列），并且还可以创建临时线程，此时才会创建临时线程。</li></ul></li><li><p>什么时候会开始拒绝新任务？</p><ul><li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">es.execute(target);<span class="comment">// 核心线程</span></span><br><span class="line">es.execute(target);<span class="comment">// 核心线程</span></span><br><span class="line">es.execute(target);<span class="comment">// 核心线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列，4个任务</span></span><br><span class="line">es.execute(target);</span><br><span class="line">es.execute(target);</span><br><span class="line">es.execute(target);</span><br><span class="line">es.execute(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心线程沾满，任务队列已满，此时创建临时线程</span></span><br><span class="line">es.execute(target);<span class="comment">//临时线程</span></span><br><span class="line">es.execute(target);<span class="comment">//临时线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新任务，全满，拒绝</span></span><br><span class="line">es.execute(target);</span><br></pre></td></tr></table></figure></li><li><p>新任务拒绝策略</p><img src="/posts/5ea3/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%96%B0%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" class="" title="多线程-新任务拒绝策略"></li></ul><h5 id="线程池处理Callable任务"><a href="#线程池处理Callable任务" class="headerlink" title="线程池处理Callable任务"></a>线程池处理Callable任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;<span class="comment">// 执行Callable任务，返回未来任务对象，用于获取线程返回的结果。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;<span class="comment">//关掉线程池（等待任务执行完毕后）</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;<span class="comment">//立即关掉线程池，返回没有执行完的任务列表。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+ <span class="string">&quot;计算1-&quot;</span>+ n + <span class="string">&quot;求和结果为：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; f1 = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">Future&lt;String&gt; f2 = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">Future&lt;String&gt; f3 = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">Future&lt;String&gt; f4 = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line">Future&lt;String&gt; f5 = es.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(f1.get());</span><br><span class="line">System.out.println(f2.get());</span><br><span class="line">System.out.println(f3.get());</span><br><span class="line">System.out.println(f4.get());</span><br><span class="line">System.out.println(f5.get());</span><br></pre></td></tr></table></figure><h4 id="Executors工具类实现线程池"><a href="#Executors工具类实现线程池" class="headerlink" title="Executors工具类实现线程池"></a>Executors工具类实现线程池</h4><ul><li>是一个线程池的工具类，提供了很多静态方法用于返回不同特点的线程池对象。</li></ul><img src="/posts/5ea3/Executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" class="" title="Executors工具类创建线程池"><p><strong>如何确定核心线程的数量</strong></p><ul><li>计算密集型任务：核心线程数量 &#x3D; CPU的核数 + 1</li><li>IO密集型任务：核心线程数量 &#x3D; CPU核数 * 2</li></ul><p><strong>大型并发系统中不允许使用Executors工具类创建线程池</strong></p><p>ThreadPoolExcutor的方式可以自己设置核心线程数量，最大线程数量，任务队列数量，更好的实现资源控制。</p><img src="/posts/5ea3/Executors%E5%BC%8A%E7%AB%AF.png" class="" title="Executors弊端"><h3 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>正在运行的程序（软件）就是一个独立的进程。</li><li>线程是属于进程的，一个进程中可以同时运行多个线程。</li><li>进程中的多个线程其实是并发和并行执行的。</li></ul><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul><li>进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快， 给我们的感觉这些线程在同时执行，这就是并发。</li></ul><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><ul><li>在同一时刻，同时有多个线程在被CPU调度执行。</li></ul><p>多线程的执行其实是并发和并行同时进行的。</p><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul><li>也就是线程从生到死的过程中，经历的各种状态及状态转换。</li><li>Java总共定义了6种状态，定义在了Thread类的内部枚举类中。</li></ul><img src="/posts/5ea3/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" class="" title="线程生命周期转换图"><p><strong>注意：sleep方法不会释放锁，睡醒继续进入可执行状态。wait方法会释放锁</strong>。</p><h3 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁&amp;乐观锁"></a>悲观锁&amp;乐观锁</h3><ul><li>悲观锁：一上来就加锁，没有安全感，每次只能一个线程进入访问完毕后，再解锁。线程安全，但性能较差。</li><li>乐观锁（基于CAS算法）：一开始不上锁，认为没有问题。等要出现线程安全问题的时候，才开始控制。线程安全，性能较好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/posts/1d9c/"/>
      <url>/posts/1d9c/</url>
      
        <content type="html"><![CDATA[<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>用于读写数据（可以读写文件、网络中的数据）。</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>标准<strong>ASCII</strong>字符集使用1个字节来存储一个字符，首位是0，总共可表示128个字符。</p><p><strong>GBK</strong>字符集使用2个字节来存储一个中文字符，同时兼容ASCII。规定第一个字节的第1位必须是1。</p><p><strong>Unicode</strong>字符集又称统一码，可以容纳所有字符集。</p><ul><li>UTF-8，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节。</li><li>UTF-8英文字符、数字等占1个字节，汉字字符占用3个字节。</li></ul><h3 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码&amp;解码"></a>编码&amp;解码</h3><p>编码：将字符按照指定字符集编码成字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] getBytes(String charsetName);</span><br></pre></td></tr></table></figure><p>解码：将字节按照指定字符集解码为字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="type">byte</span>[] bytes,String charsetName);</span><br></pre></td></tr></table></figure><h3 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h3><p>I：输入流，负责把数据读到内存中。</p><p>O：输出流，负责写数据出去（磁盘，网络）。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.构造方法,建立流管道。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String pathName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取文件的字节数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>; <span class="comment">//读取一个字节，文件结束返回-1.</span></span><br><span class="line"><span class="keyword">while</span>((b = in.read())!=-<span class="number">1</span>); <span class="comment">//循环读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流，释放系统资源。</span></span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">一次读一个字节存在问题：</span><br><span class="line">    读取性能差，频繁调用系统资源读取硬盘数据。</span><br><span class="line">    一次读取一个字节，碰到汉字时，会遇到乱码问题，因为汉字都是<span class="number">2</span>个或者<span class="number">3</span>个字节编码一个字符。</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">while</span>((len=in.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len));<span class="comment">//每次读取多个字节,读取多少要倒出多少</span></span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">一次读多个字节可以改善读取性能差的问题，但是可能还是会对汉字字节截断，导致乱码问题。</span><br><span class="line">解决：让buffer字节数组大小等于文件大小，一次性取出所有字节进行解码。</span><br><span class="line">readAllBytes();<span class="comment">//读取全部字节,返回字节数组</span></span><br><span class="line">文件过大的话，也可能存在内存溢出的问题</span><br></pre></td></tr></table></figure><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>写字节数据到文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建字节输出流管道与目标文件接通。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(String path);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(String path,<span class="type">boolean</span> append);<span class="comment">//是否追加内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.开始写字节数据。</span></span><br><span class="line">out.write(<span class="type">int</span> i);<span class="comment">//写一个字节</span></span><br><span class="line">out.write(<span class="type">byte</span>[] b);<span class="comment">//写字节数组</span></span><br><span class="line">out.write(<span class="type">byte</span>[] b,<span class="type">int</span> offset,<span class="type">int</span> len);<span class="comment">//从offset位置开始写长度为len的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流</span></span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>使用文件字节输入流和文件字节输出流完成。</p><h4 id="释放资源的方式"><a href="#释放资源的方式" class="headerlink" title="释放资源的方式"></a>释放资源的方式</h4><ul><li>try-catch-finally：无论try中代码是否正常执行，还是出现异常，finally中的代码都会执行，除非JVM停止。一般用于程序执行完成后的资源释放操作。</li><li>try-with-resource：解决try-catch-finally代码臃肿的问题。资源用完后会自动关闭。资源指实现了AutoCloseable接口的类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try-with-resource</span></span><br><span class="line"><span class="keyword">try</span>(定义资源<span class="number">1</span>;定义资源<span class="number">2</span>;...)&#123;</span><br><span class="line">    可能出现异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">    异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p>构造方法与字符流一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read();<span class="comment">//每次读取一个字符</span></span><br><span class="line">read(<span class="type">char</span>[] buffer);<span class="comment">//每次用字符数组来读取数据</span></span><br></pre></td></tr></table></figure><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String filepath,<span class="type">boolean</span> append)</span>;<span class="comment">//是否追加</span></span><br><span class="line"></span><br><span class="line">write(<span class="type">int</span> c);<span class="comment">//写一个字符</span></span><br><span class="line">write(String c);<span class="comment">//写一个字符串</span></span><br><span class="line">write(String c,<span class="type">int</span> pos,<span class="type">int</span> len);<span class="comment">//写字符串一部分</span></span><br><span class="line">write(<span class="type">char</span>[] buffer);<span class="comment">//写字符数组</span></span><br><span class="line">write(<span class="type">char</span>[] buffer,<span class="type">int</span> pos,<span class="type">int</span> len);<span class="comment">//写字符数组的一部分</span></span><br></pre></td></tr></table></figure><p><strong>注意：字符输出流写出数据后（实际是写入到缓冲区），必须刷新流，或者关闭流，写出去的数据才能生效。</strong></p><p>字节流适用于一切文件数据的拷贝（音视频，文本）；字节流不适合读取中文内容输出。</p><p>字符流适合做文本文件的操作（读，写）。</p><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>原理：缓冲流会在内存中创建一个缓冲池，读写数据的时候，先把数据放到缓冲池中，可以减少系统调用，提高性能。</p><p>硬盘 &#x3D;&gt; 输入缓冲池 &#x3D;&gt; 字节（字符）数组 &#x3D;&gt; 输出缓冲池 &#x3D;&gt; 硬盘</p><p>缓冲池相当于一个中间缓存平台，字节（字符）数组从中读写数据（在内存中操作）。</p><p>步骤：对原始的字节流、字符流进行包装。</p><h4 id="BufferedInputStream-BufferedOutputStream"><a href="#BufferedInputStream-BufferedOutputStream" class="headerlink" title="BufferedInputStream&amp;BufferedOutputStream"></a>BufferedInputStream&amp;BufferedOutputStream</h4><p>默认设置8K的字节缓冲池，也可以自行更改。</p><h4 id="BufferedReader-BufferedWriter"><a href="#BufferedReader-BufferedWriter" class="headerlink" title="BufferedReader&amp;BufferedWriter"></a>BufferedReader&amp;BufferedWriter</h4><p>默认设置8K的字符缓冲池，也可以自行更改。</p><p><strong>注意：低级字节流不一定比缓冲流慢，当字节（字符）数组开辟的比较大的时候，性能和缓冲流差不多。</strong></p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>为什么需要转换流？</p><p>代码的编码如果与要读取的文件编码不一致时，会产生乱码现象。</p><p>转换流可以设置读写的字符集。</p><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><p>解决乱码思路：先获取文件的原始字节流，再将其按照真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream is,String charset)</span> <span class="comment">//把原始的字节输入流，按照指定字符集编码转成字符输入流</span></span><br></pre></td></tr></table></figure><h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><p>需要控制写出去的字符使用什么字符集编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out,String charset)</span> <span class="comment">//把原始的字节输出流，按照指定字符集编码转成字符输出流</span></span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>作用：打印流可以实现更方便、更高效地打印数据出去。代码写地啥，打印就是啥，不会出现代码写的’a’,打印97。</p><h4 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h4><h4 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h4><p>System.out默认指向控制台，也可以重定向输出流。</p><p>System.setOut(PrintStream ps);&#x2F;&#x2F;设置输出流</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>允许将数据和其类型一并写出去。</p><h4 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readByte(<span class="type">int</span> v);<span class="comment">//写byte数据</span></span><br><span class="line">readreadInt(<span class="type">int</span> v);<span class="comment">//写int数据</span></span><br><span class="line">readDouble(Double d);<span class="comment">//写double数据</span></span><br><span class="line">readUTF(String s);<span class="comment">//将字符串按utf-8的编码写入输出流</span></span><br></pre></td></tr></table></figure><h4 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">writeByte(<span class="type">int</span> v);<span class="comment">//写byte数据</span></span><br><span class="line">writeInt(<span class="type">int</span> v);<span class="comment">//写int数据</span></span><br><span class="line">writeDouble(Double d);<span class="comment">//写double数据</span></span><br><span class="line">writeUTF(String s);<span class="comment">//将字符串按utf-8的编码写入输出流</span></span><br></pre></td></tr></table></figure><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><p>对象如果需要序列化，必须实现Serializable接口。</p><p><strong>注意：不想要参与序列化的参数，比如密码，可以添加修饰符transient进行修饰。</strong></p><p>对象序列化：把Java对象写入到文件中去。</p><p>对象反序列化：把文件中的Java对象读出来。</p><h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object o);</span><br></pre></td></tr></table></figure><h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject();</span><br></pre></td></tr></table></figure><h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><ul><li>框架指解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发。</li><li>框架的形式一般是把类、接口等编译成class形式，再压缩成jar包发行出去。</li></ul><h4 id="commons-io"><a href="#commons-io" class="headerlink" title="commons-io"></a>commons-io</h4><ul><li>apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileUtils类</span></span><br><span class="line">copyFile(File src,File dest);<span class="comment">//复制文件</span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/posts/b543/"/>
      <url>/posts/b543/</url>
      
        <content type="html"><![CDATA[<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><ul><li>Stream流是JDK8开始新增的一套API，可以用于操作集合或者数组的数据。</li><li>优势：Stream流大量的结合了Lambda语法风格编程，提供了一种更加强大、简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。</li><li>步骤：获取Stream流；调用流的各种方法对数据进行处理、计算；获取计算的结果，收集到新的集合中返回。</li></ul><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Collection集合的Stream流</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组的Stream流</span></span><br><span class="line">Arrays.stream(T[] array);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取接收数据的Stream流</span></span><br><span class="line">Stream.of(T...values);</span><br></pre></td></tr></table></figure><h3 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h3><p>中间方法指的是调用完成后会返回新的Stream流，可以继续使用（支持链式编程）。</p><ul><li>过滤 fileter()</li><li>排序 sorted()</li><li>取前k个数据 limit(k)</li><li>跳过前k个数据 skip(k)</li><li>去重 distinct()</li><li>映射 map()</li><li>合并流 concat(s1,s2)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.找出成绩大于60分的数据，并升序排列然后输出。</span></span><br><span class="line">list.stream().filter(s -&gt; s&gt;=<span class="number">60</span>).sorted().forEach(s -&gt; sout(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.找出年龄大于等于23，且年龄小于30的学生，并按照年龄降序输出。</span></span><br><span class="line">students.stream().filter(s -&gt; s.getAge()&gt;=<span class="number">23</span> &amp;&amp; s.getAge()&lt;=<span class="number">30</span>).sorted((o1,o2) -&gt; o2.getAge()-o1.getAge()).forEach(s -&gt; sout(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.找出身高前3名的学生，并输出。</span></span><br><span class="line">students.stream().sorted((s1,s2) -&gt; Double.compare(s2.getHeight(),s1.getHeight())).limit(<span class="number">3</span>).forEach(s -&gt; sout(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.取出身高倒数2名的学生，并输出。</span></span><br><span class="line">students.stream().sorted((s1,s2) -&gt; Double.compare(s2.getHeight(),s1.getHeight())).skip(students.size()-<span class="number">2</span>).forEach(s -&gt; sout(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。</span></span><br><span class="line">students.stream().filter(s -&gt; s.getHeight()&gt;<span class="number">168</span>).map(s -&gt; s.getName()).distinct().forEach(s -&gt; sout(s));</span><br></pre></td></tr></table></figure><h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p>终结方法指的是调用后不会再返回Stream了，没法继续使用流了。</p><ul><li>forEach()</li><li>count() 计数</li><li>max(Comparator)</li><li>min()</li><li>收集stream流<ul><li>collect(Collectors.toList())</li><li>collect(Collectors.toSet())</li><li>collect(Collectors.toMap())</li><li>toArray() 收集到数组中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.计算出身高超过168的学生有几人</span></span><br><span class="line">students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.找出身高最高的学生对象，并输出</span></span><br><span class="line">students.stream().max((o1,o2) -&gt; Double.compare(o1.getHeight() - o2.getHeight())).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.找出身高最矮的学生对象，并输出</span></span><br><span class="line">students.stream().min((o1,o2) -&gt; Double.compare(o1.getHeight() - o2.getHeight())).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.请找出身高超过170的对象，并放到一个新集合中去返回</span></span><br><span class="line">List&lt;Students&gt; list = students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.请找出身高超过170的对象，并将学生对象的名字和身高，存入到一个Map集合返回</span></span><br><span class="line">Map&lt;String,Double&gt; map = students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">170</span>).distinct().collect(Collectors.toMap(s -&gt; s.getName(),s -&gt; s.getAge()));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架（二）</title>
      <link href="/posts/ffe0/"/>
      <url>/posts/ffe0/</url>
      
        <content type="html"><![CDATA[<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul><li>Map集合键是不允许重复的，但是值是可以重复的。</li><li>Map&lt;K,V&gt;<ul><li>HashMap&lt;K,V&gt; 无序，不重复，无索引<ul><li>LinkedHashMap&lt;K,V&gt; 有序、不重复、无索引</li></ul></li><li>TreeMap&lt;K,V&gt; 按键大小默认升序排序、不重复、无索引</li></ul></li><li>Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的。</li></ul><h2 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h2><ul><li>键找值：先获取Map集合全部的键，再通过遍历键来找值。</li><li>键值对：把“键值对”看成一个整体进行遍历。</li><li>Lambda：JDK8之后的新技术。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.键找值</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key:keys)&#123;</span><br><span class="line">    <span class="comment">//根据键获取对应的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.键值对</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry:entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Lambda</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String,String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k,String v)</span>&#123;</span><br><span class="line">        sout(k+<span class="string">&quot;---&gt;&quot;</span>+v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((k,v) -&gt; sout(k+<span class="string">&quot;---&gt;&quot;</span>+v));</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap跟HashSet的底层原理是一摸一样的，都是基于哈希表实现的。</p><p>HashSet实际就是HashMap不要值数据而已。</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>有序、不重复、无索引。</p><p>底层数据结构还是基于哈希表来实现的，只是每个键值对又额外多了一个双链表的机制（头指针，尾指针）来记录元素顺序。</p><p>LinkedHashSet的底层就是依据LinkedHashMap来实现的。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap底层原理和TreeSet一致，都是基于红黑树实现。</p><h2 id="集合的嵌套"><a href="#集合的嵌套" class="headerlink" title="集合的嵌套"></a>集合的嵌套</h2><p>集合中的元素又是一个集合。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架</title>
      <link href="/posts/75dc/"/>
      <url>/posts/75dc/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h2><ul><li><strong>Collection</strong>（单列集合）<ul><li><strong>List</strong>：有序、可重复、有索引<ul><li>ArrayList</li><li>LinkedList</li></ul></li><li><strong>Set</strong>：无序、不重复、无索引<ul><li>HashSet<ul><li>LinkedHashSet：有序、不重复、无索引</li></ul></li><li>TreeSet：按照大小默认升序排序、不重复、无索引</li></ul></li></ul></li><li><strong>Map</strong>（双列集合）</li></ul><p>有序无序指的是：从集合中插入和取出元素的顺序是否一致。</p><h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">add();</span><br><span class="line"><span class="comment">//2.清空集合</span></span><br><span class="line">clear();</span><br><span class="line"><span class="comment">//3.判断空</span></span><br><span class="line">isEmpty();</span><br><span class="line"><span class="comment">//4.集合大小</span></span><br><span class="line">size();</span><br><span class="line"><span class="comment">//5.包含</span></span><br><span class="line">contains(Object o);</span><br><span class="line"><span class="comment">//6.删除,默认删除重复元素的第一个</span></span><br><span class="line">remove(E e);</span><br><span class="line"><span class="comment">//7.集合转为数组</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//8.将一个集合的数据全部添加到另一个集合</span></span><br><span class="line">l1.addAll(List l2);</span><br></pre></td></tr></table></figure><h2 id="Collection的遍历方式"><a href="#Collection的遍历方式" class="headerlink" title="Collection的遍历方式"></a>Collection的遍历方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取迭代器对象</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> Iterator&lt;E&gt; list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">sout(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(元素数据类型 变量名：数组或者集合)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.forEach配合Lambda表达式</span></span><br><span class="line">c.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        sout(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">------ 简化 ------</span><br><span class="line">forEach(s -&gt; sout(s));</span><br></pre></td></tr></table></figure><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>List集合继承了Colection接口的所有方法，除此之外还具有包含索引的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="type">int</span> index,E ele);</span><br><span class="line">remove(<span class="type">int</span> index);</span><br><span class="line">get(<span class="type">int</span> index);</span><br><span class="line">set(<span class="type">int</span> index,E ele)</span><br></pre></td></tr></table></figure><h3 id="List遍历方式"><a href="#List遍历方式" class="headerlink" title="List遍历方式"></a>List遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.for循环</span></span><br><span class="line">list.fori;</span><br><span class="line"><span class="comment">//2.迭代器</span></span><br><span class="line">list.iterator();</span><br><span class="line"><span class="comment">//3.增强for</span></span><br><span class="line">list.<span class="keyword">for</span>;</span><br><span class="line"><span class="comment">//4.forEach配合lambda</span></span><br><span class="line">list.forEach(l -&gt; sout(l));</span><br></pre></td></tr></table></figure><h3 id="ArrayList集合的底层原理"><a href="#ArrayList集合的底层原理" class="headerlink" title="ArrayList集合的底层原理"></a>ArrayList集合的底层原理</h3><ul><li><strong>基于数组实现。</strong></li><li>查询速度快（根据索引查询快）</li><li>删除效率低（可能需要把后面的元素前移）</li><li>添加效率极低（可能需要把后面数据后移，再添加数据；还有可能需要进行数组扩容）</li></ul><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>​① 利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组，用size来记录数组的大小。<br>​② 第一次添加元素的时候，底层会创建一个新的长度为10的数组。<br>​③ 存满时，会扩容1.5倍。（创建新数组，把原来的数据拷贝进来）。<br>​④ 如果一次添加的元素，1.5倍放不下，则新创建的数组长度以实际为准。</p><h4 id="ArrayList的应用场景"><a href="#ArrayList的应用场景" class="headerlink" title="ArrayList的应用场景"></a>ArrayList的应用场景</h4><ul><li>适合根据索引查询数据频繁的场景</li><li>适合数据量不是很大的场景</li><li>不适合数据量大又需要进行增删操作的场景。</li></ul><h3 id="LinkedList集合的底层原理"><a href="#LinkedList集合的底层原理" class="headerlink" title="LinkedList集合的底层原理"></a>LinkedList集合的底层原理</h3><ul><li><strong>基于双链表实现。</strong></li><li>查询慢，无论查询哪个数据都要从头开始查找。</li><li>增删相对快。</li></ul><p>LinkedList对首尾元素进行增删改查的速度是极快的。相比List多了很多针对首尾元素的特有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addFirst(E e);<span class="comment">//表头插入元素</span></span><br><span class="line">addLast(E e);<span class="comment">//表尾插入元素</span></span><br><span class="line">getFirst();<span class="comment">//获取表头元素</span></span><br><span class="line">getLast();<span class="comment">//获取表尾元素</span></span><br><span class="line">removeFirst();<span class="comment">//删除表头</span></span><br><span class="line">removeLast();<span class="comment">//删除表尾</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList应用场景"><a href="#LinkedList应用场景" class="headerlink" title="LinkedList应用场景"></a>LinkedList应用场景</h4><ul><li><p>用来设计队列，先进先出，后进后出（经常操作首尾数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.addLast();</span><br><span class="line">queue.removeFirst();</span><br></pre></td></tr></table></figure></li><li><p>用来设计栈，先进后出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.addFirst();</span><br><span class="line">stack.removeFirst();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序、不重复、无索引。</p><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul><li><p>就是一个int类型的数值，Java中每个对象都有哈希值。</p></li><li><p>Java中所有对象，都可以调用Object类提供的hashCode方法，返回该对象的哈希值。</p></li><li><p>不同对象哈希值不同，但也可能会相同（哈希碰撞）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h4><ul><li>基于哈希表实现。</li><li>哈希表是一种增删改查数据，性能都较好的数据结构。</li><li>JDK8之前，哈希表 &#x3D; 数组 + 链表</li><li>JDK8之后，哈希表 &#x3D; 数组 + 链表 + 红黑树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1，创建一个默认长度为16的数组，默认加载因子为0.75，数组名table</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 2，使用元素的哈希值对数组的长度求余计算元素应该存入数组中的位置</span></span><br><span class="line">set.add(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line"><span class="comment">// 3，判断存入位置是否为null，如果是null则直接存入</span></span><br><span class="line"><span class="comment">// 4，如果不为null，表示当前位置有元素，则调用equals方法比较</span></span><br><span class="line"><span class="comment">//4，1 比较相等的话，则不存</span></span><br><span class="line"><span class="comment">//4，2 比较不相等的话，则存入数组</span></span><br><span class="line"><span class="comment">//4，2，1 JDK8之前，新元素存入数组，占老元素位置，老元素挂在下面</span></span><br><span class="line"><span class="comment">//4，2，2 JDK8之后，新元素直接挂在老元素下面</span></span><br></pre></td></tr></table></figure><p><strong>如果数组快占满了，会出现什么问题？</strong></p><p>如果数组快占满了，数据可以沿着链表继续往下存，但是链表过长的话，会导致查询性能降低。</p><h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>当数组中的元素占据了长度16*加载因子0.75 &#x3D; 12个位置时，就会开始扩容，扩容为原来的两倍。但是还是会存在一种情况，某个位置的链表依然过长，JDK8之后规定，当链表长度超过8时，且数组长度&gt;&#x3D;64时，自动将链表转为红黑树。</p><h4 id="去重复机制"><a href="#去重复机制" class="headerlink" title="去重复机制"></a>去重复机制</h4><p>HashSet集合默认不能对内容一样的两个不同对象去重复！</p><p>如何让HashSet去重复？</p><p>如果希望Set集合认为两个内容一样的对象是重复的，必须重写对象的hashCode和equals方法，让内容一样的对象具备一样的hashCode，然后再使用equals比较。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>有序、不重复、无索引</p><h4 id="LinkedHashSet底层原理"><a href="#LinkedHashSet底层原理" class="headerlink" title="LinkedHashSet底层原理"></a>LinkedHashSet底层原理</h4><ul><li>基于哈希表实现（数组，链表，红黑树）实现的。</li><li>但是，它的每个元素都额外的多了一个双链表机制记录它前后元素的位置。（双链表来实现有序，指针多，内存换有序）</li></ul><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>可排序，不重复、无索引</p><p>底层使用红黑树实现排序。</p><h2 id="集合并发修改异常问题"><a href="#集合并发修改异常问题" class="headerlink" title="集合并发修改异常问题"></a>集合并发修改异常问题</h2><ul><li><p>使用迭代器遍历集合时，又同时在删除集合中的数据，程序就会出现并发修改异常的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用for循环删除[体育，体制，语文，数学，体验]中含有‘体’的字段</span></span><br><span class="line"><span class="comment">//[体育，体制，语文，数学，体验]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);<span class="comment">//[体制, 语文, 数学]</span></span><br><span class="line"><span class="comment">//这里体制没有被删掉，因为体育在被删掉的同时，体制会去到前一个位置，而索引还在往后加，因此直接略过体制字段。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何解决此问题？</span></span><br><span class="line"><span class="comment">//在每次删除元素时，需要让索引自减，即i--，或者倒着遍历删除元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">        i--; <span class="comment">//索引自减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);<span class="comment">//[语文, 数学]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用迭代器遍历元素的时候删除元素</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">    <span class="keyword">if</span> (str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)</span></span><br><span class="line"><span class="comment">at java.util.ArrayList$Itr.next(ArrayList.java:861)</span></span><br><span class="line"><span class="comment">at com.zhouquan.delete.Delete.main(Delete.java:27)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//会报并发修改异常。</span></span><br><span class="line"><span class="comment">//如何解决？</span></span><br><span class="line"><span class="comment">//使用迭代器自己的删除方法，不要使用集合的删除方法。</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">    <span class="keyword">if</span> (str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        it.remove(); <span class="comment">//使用迭代器自己的删除，删除当前遍历到的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Collections的其他相关知识"><a href="#Collections的其他相关知识" class="headerlink" title="Collections的其他相关知识"></a>Collections的其他相关知识</h2><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li>就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型…参数名称；</li><li>特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。</li><li>好处：常常用来灵活的接收数据。</li><li>注意：形参列表中，只能有一个可变形参，且必须放在列表的最后面。</li></ul><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>操作集合的工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addAll(Collection&lt;? <span class="built_in">super</span> T&gt; c, T...elements);<span class="comment">//为集合批量添加数据</span></span><br><span class="line">shuffle(List&lt;?&gt; list); <span class="comment">//打乱List集合的数据，类似洗牌</span></span><br><span class="line">sort(List&lt;?&gt; list); <span class="comment">//对List集合排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用API（二）</title>
      <link href="/posts/bcca/"/>
      <url>/posts/bcca/</url>
      
        <content type="html"><![CDATA[<h1 id="常用API（二）"><a href="#常用API（二）" class="headerlink" title="常用API（二）"></a>常用API（二）</h1><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>用于解决浮点型运算时，出现结果失真的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BigDecimal常见构造器、方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(<span class="type">double</span> d)</span>;<span class="comment">//禁止使用，还是存在精度的问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(String val)</span>; <span class="comment">//把String转成BigDecimal，底层用数组来存储每一位来运算。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将double值转包装成BigDecimal类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将BigDecimal转换成基础类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//加、减、乘、除</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">substract</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意除法</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(另一个数,精度几位,取舍模式)</span>;</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.1</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.3</span>);</span><br><span class="line">b1.divide(b2);<span class="comment">//这里会报错，因为无法整除，小数计算不知道保留几位</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> b1.divide(b2,<span class="number">2</span>,RoundingMode.HALF_UP);</span><br><span class="line">c.doubleValue();</span><br></pre></td></tr></table></figure><h2 id="日期、时间（JDK8之前）"><a href="#日期、时间（JDK8之前）" class="headerlink" title="日期、时间（JDK8之前）"></a>日期、时间（JDK8之前）</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>代表日期和时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>; <span class="comment">//创建一个Date对象，代表的是系统当前此刻日期时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>; <span class="comment">//把时间毫秒值转换成Date日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常见方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>; <span class="comment">//返回从1970年1月1日 0:0:0走到此刻的总毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>; <span class="comment">//设置日期对象的时间为当前时间毫秒值对应的时间</span></span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>将日期对象或者时间毫秒值格式化成想要的时间形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">(String pattern)</span>; <span class="comment">//创建简单日期格式化对象，并封装时间格式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期对象或者时间毫秒值格式化成想要的时间形式。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span>; <span class="comment">//格式化日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Object time)</span>; <span class="comment">//格式化时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串时间转换成日期对象</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2022-12-22 12:12:11&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(dateStr);</span><br></pre></td></tr></table></figure><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>代表的是系统此刻时间对应的日历。</p><p>通过它可以单独获取、修改时间中的年、月、日、时、分、秒等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//获取当前日历对象</span></span><br><span class="line">now.get(Calendar.YEAR); <span class="comment">//获取日历中的某个信息</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> now.getTime();<span class="comment">//获取日期对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> now.getTimeMillis();<span class="comment">//获取时间毫秒值</span></span><br><span class="line">now.set(<span class="type">int</span> field,<span class="type">int</span> value);<span class="comment">//设置日历中某个信息</span></span><br></pre></td></tr></table></figure><h2 id="日期、时间（JDK8之后）"><a href="#日期、时间（JDK8之后）" class="headerlink" title="日期、时间（JDK8之后）"></a>日期、时间（JDK8之后）</h2><p>略</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印数组内容，字符串的形式拼接起来</span></span><br><span class="line">Arrays.toString(类型[] arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝数组</span></span><br><span class="line">Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">4</span>); <span class="comment">//范围包前不包后</span></span><br><span class="line">Arrays.copyOf(arr,<span class="number">10</span>);<span class="comment">// 拷贝数组，10比原数组大的话，相当于扩容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr); <span class="comment">//默认升序排序</span></span><br></pre></td></tr></table></figure><p>如果sort中传入的数组比较复杂，Java不知道以何种规则进行比较，就需要手动定义规则。有两种方式：</p><ul><li><p>让该对象类实现Comparable接口，然后重写compareTo方法，自已定制比较规则。</p></li><li><p>使用下面的sort方法，创建Comparator比较器接口的匿名内部类对象，然后制定比较规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是JDK 8开始新增的一种语法形式；作用：用于简化匿名内部类的代码写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">(被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">    被重写方法的方法体代码。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：Lambda表达式只能简化函数式接口的匿名内部类</strong>。</p><p>函数式接口：1，接口  2，内部有且仅有1个抽象方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用API</title>
      <link href="/posts/c56f/"/>
      <url>/posts/c56f/</url>
      
        <content type="html"><![CDATA[<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的祖宗类。因此，Java中所有类的对象都可以直接使用Object类提供的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">//返回对象的字符串形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>; <span class="comment">//判断两个对象是否相等，默认判断地址</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>; <span class="comment">//返回对象的副本</span></span><br></pre></td></tr></table></figure><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o1,Object o2)</span>; <span class="comment">// 更安全。先做非空判断，再比较两个对象，防止空指针异常bug。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Object obj)</span>;<span class="comment">// 判断对象是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">nonNull</span><span class="params">(Object o)</span>;<span class="comment">// 判断对象是否不为空</span></span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类就是将基本数据类型封装成对象。</p><p>泛型和集合的使用是不支持基本数据类型的，因此需要包装类来支撑。</p><p>自动装箱机制：可以自动将基本数据类型转换为对象。</p><p>自动拆箱机制：可以自动将包装类型数据转换为对应的基本数据类型。</p><ul><li><p>Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="type">int</span>); <span class="comment">//基本数据类型转换为包装类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> i;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="包装类的其他操作"><a href="#包装类的其他操作" class="headerlink" title="包装类的其他操作"></a>包装类的其他操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把基本类型的数据转换成字符串</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">a_s</span> <span class="operator">=</span> Integer.toString(a); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.把字符串类型的数据转换为对应的基本类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;23&quot;</span>);</span><br><span class="line"><span class="type">double</span> = Double.parseDouble(<span class="string">&quot;23.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Integer.valueOf(<span class="string">&quot;23&quot;</span>);</span><br><span class="line">Double.valueOf(<span class="string">&quot;23.1&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>String对象是不可变的。</strong></p><p><strong>双引号创建的字符串对象，存储在堆内存的字符串常量池中，且相同内容的字符串只存储一份。</strong></p><p><strong>new关键字创建出来的字符串对象，每次new都会产生一个新的对象存储在堆内存中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">sout(s1 == s2); <span class="comment">// true 比较地址，相同内容只存储一份</span></span><br><span class="line">    </span><br><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">sout(s1 == s2); <span class="comment">// false new创建的对象都是新的对象，地址不一样</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//面试题1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 此行代码创建了2个对象，一个是“abc”存储在字符串常量池，一个是new关键字创建的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 此行代码创建了0个对象，因为直接使用的是字符串常量池的“abc”</span></span><br><span class="line">sout(s1 == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;c&quot;</span>; <span class="comment">// 字符串变量运算会在堆内存中创建新对象 </span></span><br><span class="line">sout(s1 == s3); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题3</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>; <span class="comment">// 确定的常量，编译器会在编译时，直接将&quot;a&quot; + &quot;b&quot; + &quot;c&quot;转成&quot;abc&quot;,以提高程序的性能。</span></span><br><span class="line">sout(s1 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><p>StringBuilder代表可变字符串对象，相当于一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。</p><p>好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁。</p><p>StringBuilder是线程不安全的，StringBuffer是线程安全的。</p><h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringJoiner拼接字符串</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span> ,<span class="string">&quot;]&quot;</span>); <span class="comment">//分隔符,开始符号，结束符号</span></span><br><span class="line">s.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">sout(s);<span class="comment">// [java1, java2, java3]</span></span><br></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>代表数学，是一个工具类，里面提供的都是对数据进行操作的一些静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span>; <span class="comment">//获取绝对值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//向上取整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//向下取整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">round</span><span class="params">(<span class="type">float</span> a)</span>; <span class="comment">//四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span>; <span class="comment">//获取两个int值中的较大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>; <span class="comment">//返回a的b次幂的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span>; <span class="comment">//返回值为double的随机值，范围[0.0,1.0)</span></span><br></pre></td></tr></table></figure><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>System代表程序所在的系统，也是一个工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>; <span class="comment">//终止当前运行的Java虚拟机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>; <span class="comment">//返回当前系统的时间毫秒值形式，指从1970-1-1 0:0:0 开始到此刻的毫秒值。可以用来统计某段程序运行时间。</span></span><br></pre></td></tr></table></figure><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>Runtime代表程序所在的运行环境，Runtime是一个单例类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">r.exit(<span class="type">int</span>); <span class="comment">//非0状态码表示异常终止</span></span><br><span class="line">r.availableProcessors();<span class="comment">//获取虚拟机能够使用的处理器数</span></span><br><span class="line">r.totalMemory();<span class="comment">//返回Java虚拟机中的内存总量</span></span><br><span class="line">r.freeMemory();<span class="comment">//返回Java虚拟机中的可用内存量</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> r.exec(String command);<span class="comment">//启动某个程序，并返回代表该程序的对象</span></span><br><span class="line">Thread。sleep(<span class="number">5000</span>);<span class="comment">//程序停5秒</span></span><br><span class="line">p.destroy()<span class="comment">//销毁程序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象（二）</title>
      <link href="/posts/c2dd/"/>
      <url>/posts/c2dd/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象（二）"><a href="#Java面向对象（二）" class="headerlink" title="Java面向对象（二）"></a>Java面向对象（二）</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>如果一个类定义在另一个类的内部，那么这个类就是内部类。</p><p>场景：当一个类的内部，包含了一个完成的事物，且这个事物没有必要单独设计时，就可以把这个事物设计为内部类。</p><ul><li><p>成员内部类：类中的一个普通成员，类似于成员变量。可以访问外部内中的任何成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outet.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">Outer.<span class="built_in">this</span> <span class="comment">//拿到外部类对象</span></span><br></pre></td></tr></table></figure></li><li><p>静态内部类：有static修饰的内部类，属于外部类自己持有。只能访问外部类的静态成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure></li><li><p>局部内部类：局部内部类是定义在方法中、代码块中、构造器等执行体中的类。</p></li><li><p><strong>匿名内部类</strong>：特殊的局部内部类，不需要为其声明名字。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名内部类书写格式，会将其编译成一个子类，然后立即创建一个子类对象出来。</span></span><br><span class="line"><span class="type">Anaimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;喵喵喵~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象。</span><br><span class="line">作用：用于更方便的创建一个子类对象。</span><br></pre></td></tr></table></figure></li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是一种特殊类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法</span></span><br><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    名称<span class="number">1</span>,名称<span class="number">2</span>,...;</span><br><span class="line">    其他成员...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X,Y,Z;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;A.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;A&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">X</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">Z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A[] values();<span class="comment">// 拿到全部对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>; <span class="comment">//根据名字得到对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类本身的一个对象。</li><li>枚举类的构造器都是私有的，因此不可以创建对象。</li><li>枚举都是最终类，不可以被继承。</li><li>枚举类中，从第二行开始可以定义类的其他各种成员。</li></ul><h3 id="枚举实现单例模式"><a href="#枚举实现单例模式" class="headerlink" title="枚举实现单例模式"></a>枚举实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X; <span class="comment">//单例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举应用场景"><a href="#枚举应用场景" class="headerlink" title="枚举应用场景"></a>枚举应用场景</h3><p>用来表示一组信息，然后作为参数传输。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>定义类、接口、方法时，同时声明了一个或者多个类型变量<E>，称为泛型类、泛型接口、泛型方法。</p><p>作用：做类型限定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Car</span>&gt; <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(ArrayList&lt;T&gt; cars)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 通配符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的擦除问题和注意事项"><a href="#泛型的擦除问题和注意事项" class="headerlink" title="泛型的擦除问题和注意事项"></a>泛型的擦除问题和注意事项</h3><ul><li>泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。还是对类型进行强转。</li><li>泛型不支持基本数据类型，只能支持对象类型（引用数据类型）。</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常就是代表程序出现的问题。</p><p>如：数组越界，除零等。</p><p>Throwable</p><ul><li>Error</li><li>Exception<ul><li>RuntimeException：编译时不会出现错误提醒，运行时出现异常。</li><li>其他异常</li></ul></li></ul><p>处理异常：</p><ul><li>在方法上使用throws关键字，可以将方法内部出现的异常抛出去交给调用者处理。</li><li>捕获异常（try…catch代码块）</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li><p>自定义运行时异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个异常类继承RuntimeException</span></span><br><span class="line"><span class="comment">//2.重写构造器</span></span><br><span class="line"><span class="comment">//3.通过throw new 异常类()来创建异常对象并抛出。</span></span><br><span class="line"></span><br><span class="line">编译时不报错</span><br></pre></td></tr></table></figure></li><li><p>自定义编译时异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个异常类继承Exception</span></span><br><span class="line"><span class="comment">//2.重写构造器</span></span><br><span class="line"><span class="comment">//3.通过throw new 异常类()来创建异常对象并抛出。</span></span><br><span class="line"></span><br><span class="line">编译阶段就报错，表示问题严重，需要在代码里强烈提醒！！！</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/posts/70b0/"/>
      <url>/posts/70b0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this就是一个变量，可以用在方法中，<strong>来拿到当前对象</strong>。</p><p>this主要用来解决变量名称冲突的问题，当方法内部变量名与成员变量名一致时，使用this.成员变量名与之进行区分。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li>类在设计时，如果不写构造器，Java会为类生成一个无参的构造器。</li><li>一旦定义了有参的构造器，Java就不会帮助类生成无参构造器，此时建议手写一个无参构造器出来。</li><li>构造器用于完成对象的初始化（对成员变量进行初始化赋值）。</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>什么是封装？</p><p>封装是将数据和对数据进行操作的函数绑定到一起的机制，它将对象的数据和方法结合到一起，隐藏内部实现的细节。封装的目的是提高数据的安全性和可维护性。</p><p>封装的设计规范：合理隐藏，合理暴露。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><table><thead><tr><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>类中的位置不同</td><td>类中，方法外</td><td>常见于方法</td></tr><tr><td>初始值不同</td><td>有默认值，不需要初始化赋值</td><td>没有默认值，使用前必须先赋值</td></tr><tr><td>内存位置不同</td><td>堆内存</td><td>栈内存</td></tr><tr><td>作用域不同</td><td>整个对象</td><td>在所归属的括号内</td></tr><tr><td>生命周期不同</td><td>与对象共存亡</td><td>随着方法的调用而生，方法的运行结束而亡</td></tr></tbody></table><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>静态，可以修饰成员变量、成员方法。</p><p>成员变量按照有无static关键字修饰，可以分为两种：</p><ul><li>类变量，在内存中只存在一份，与类一起加载，被所有对象共享。</li><li>实例变量（对象的变量）</li></ul><p>成员方法按照有无static关键字修饰，可以分为：</p><ul><li>类方法</li><li>实例方法</li></ul><p><strong>注意事项</strong></p><ul><li>类方法中可以直接访问类成员，不可以直接访问实例成员。</li><li>实例方法中可以直接访问类成员，也可以直接访问实例成员</li><li>实例方法中可以出现this关键字，类方法中不可以出现this关键字</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块分为两种：</p><ul><li>静态代码块<ul><li>格式：static{}</li><li>特点：类加载时自动执行，由于类只加载一次，所以静态代码块也只执行一次。</li><li>作用：完成类的初始化，例如：对类变量的初始化赋值</li></ul></li><li>实例代码块<ul><li>格式：{}</li><li>特点：每次创建对象时，执行实例代码块，并在构造器之前执行。</li><li>作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值。</li></ul></li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul><li><p>确保一个类只有一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.饿汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.内部自己创建一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供给外部使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.懒汉式单例模式（延时加载）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//2.类变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供外部使用,调用时才创建单例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span>)&#123;</span><br><span class="line">            a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h3><p>Java中提供了一个关键字extends，可以让一个类和另一个类建立起父子关系。</p><ul><li>子类能继承父类的非私有成员（成员变量，成员方法）</li><li>子类对象是由子类、父类共同完成的。</li><li>继承可以减少重复代码的编写。</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>权限修饰符：用来限制类中成员能够被访问的范围。</p><p>权限等级：private &lt; 缺省 &lt; protected &lt; public。</p><table><thead><tr><th>修饰符</th><th>在本类中</th><th>同一包下其他类中</th><th>任意包下的子类</th><th>任意包下的任意类里</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>缺省</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>Java中的类不支持多继承，但是支持多层继承。</p><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>什么是方法重写？</p><ul><li>当子类觉得父类中某个方法不好用，或者无法满足自己的需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的方法，这就是方法重写。</li><li>重写后，方法的访问，Java遵循就近原则。</li></ul><p>注意事项：</p><ul><li>子类重写父类方法时，访问权限必须大于或等于父类该方法的权限。</li><li>重写方法的返回值类型必须与被重写方法的返回值类型一样，或者范围更小。</li><li>私有方法、静态方法不能被重写（静态方法在编译时已经与类进行了绑定，不依赖于类的实例，而是通过类名直接访问。当子类存在一个与父类静态方法相同的方法时，子类的静态方法实际会隐藏父类的静态方法，而不是进行重写。）。</li></ul><p>子类的全部构造器，都会先调用父类的构造器，再执行自己的代码。</p><ul><li>默认情况下，子类全部构造器的第一行代码都是super()，它会调用父类的无参数构造器。</li><li>如果父类没有无参数构造器，则我们必须在子类构造器的第一行手写super(…)，指定去调用父类的有参数构造器。</li></ul><p><strong>子类构造器为什么要调用父类的构造器？</strong></p><p>子类中继承了父类的部分成员，这部分成员的初始化可以通过调用父类的构造器来实现，然后再初始化子类的特有成员。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是在继承&#x2F;实现情况下的一种现象，表现为：对象多态、行为多态。</p><p>如：父类引用指向子类对象。</p><p><strong>特别注意：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//People是Teacher的父类</span></span><br><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">p1.run(); <span class="comment">//对于方法，编译看左边，运行看右边 //执行Teacher中的run方法</span></span><br><span class="line">sout(p1.name); <span class="comment">//对于变量，编译看左边，运行也看左边  //输出父类中name属性</span></span><br></pre></td></tr></table></figure><p>多态的好处：</p><ul><li>多态形式下，右边对象是解耦合的，更便于扩展和维护。</li><li>定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利。</li></ul><p>多态的问题：</p><ul><li>父类引用指向子类对象，无法直接调用子类的特有方法。（无法过编译，编译看左边）</li><li>解决这一问题，需要对父类引用进行强制类型转换，转换为子类对象。（转换前使用instanceof判断真实类型）</li></ul><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final关键字是最终的意思，可以修饰（类，方法，变量）。</p><ul><li>修饰类：该类被称为最终类，无法被继承</li><li>修饰方法：该方法被称为最终方法，无法被重写</li><li>修饰变量：该变量只能被赋值一次，之后不允许改变</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>使用了static final修饰的成员变量被称为常量。</p><p>作用：通常用于记录系统中的配置信息。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract关键字修饰类，这个类就是抽象类。</p><p>abstract修饰方法，称为抽象方法，抽象方法不能有方法体。</p><p>抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。它有构造函数，用于子类对象的初始化调用。</p><p><strong>抽象类的好处</strong>：每个子类的行为不同，因此将父类的方法定义为抽象方法，交给不同的子类去重写实现，可以更好地支持多态。</p><p><strong>应用场景：</strong>经常被用来设计模板方法设计模式。</p><h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><p>解决方法中存在重复代码的问题。</p><p>写法：</p><ul><li>1、定义一个抽象类</li><li>2、在里面定义2个方法<ul><li>一个是模板方法：把相同的代码放进去，建议用final关键字修饰模板方法。</li><li>一个是抽象方法：具体实现交给子类来完成。</li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java提供了关键字interface，用这个关键字可以定义一个特殊的结构：接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量（常量）</span></span><br><span class="line">    <span class="comment">//成员方法（抽象方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的好处：</p><ul><li>弥补了类单继承的不足，一个类可以实现多个接口，扩展更多的功能。</li><li>让程序可以面向接口编程，这样程序员就可以灵活方便地切换各种业务实现。</li></ul><p>JDK8之后接口新特性：接口中新增3种方法，方法可以写方法体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//1.默认方法，使用default修饰</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.私有方法，必须使用private修饰</span></span><br><span class="line">    priavate <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.类方法（静态方法）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要添加这些新方法？</p><ul><li>增强了接口的能力，更便于项目的扩展和维护。（要扩展新功能，只需要在接口中定义上述带方法体的方法，而不需要让实现类都来进行实现了）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/posts/981f/"/>
      <url>/posts/981f/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="JDK的组成"><a href="#JDK的组成" class="headerlink" title="JDK的组成"></a>JDK的组成</h2><p><strong>JVM</strong>：java虚拟机，运行Java程序的地方。</p><p><strong>核心类库</strong>：Java内部程序，可供程序员调用。</p><p><strong>JRE</strong>：Java运行环境，包含上述。</p><p><strong>JDK</strong>：Java开发工具包，包含上述。</p><h2 id="Java跨平台特性"><a href="#Java跨平台特性" class="headerlink" title="Java跨平台特性"></a>Java跨平台特性</h2><p><strong>一次编译，处处可用</strong></p><p>Java编译工具<code>javac</code>将源文件编译为字节码文件，不同的平台只需要安装对应的JVM就可以对字节码文件进行执行了。</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>字符在计算中怎么存的？</p><p>字符在ASCII码表中有对应的数字编号表示，计算机存储对应的二进制形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syso(<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>); <span class="comment">//97+10 输出107</span></span><br><span class="line">syso(<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>); <span class="comment">//65+10 输出75</span></span><br><span class="line">syso(<span class="string">&#x27;0&#x27;</span>+<span class="number">10</span>); <span class="comment">//48+10 输出58    </span></span><br></pre></td></tr></table></figure><h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>Java中支持书写二进制、八进制、十六进制的数据，分别用0B、0、0x开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0B01100001</span>;<span class="comment">//二进制数</span></span><br><span class="line">syso(a); <span class="comment">//输出97</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0141</span>; <span class="comment">//八进制数</span></span><br><span class="line">syso(a); <span class="comment">//输出97</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x61</span>;<span class="comment">//十六进制</span></span><br><span class="line">syso(a); <span class="comment">//输出97</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>基本数据类型：</strong>4大类8种</p><p><strong>整型</strong>：<code>byte（1字节，-128~127）</code>、<code>short（2字节）</code>、<code>int（4字节）</code>、<code>long（8字节）</code></p><p><strong>浮点型</strong>：<code>float（4字节）</code>、<code>double（8字节）</code></p><p><strong>字符型：</strong><code>char(2字节)</code></p><p><strong>布尔型</strong>：<code>boolean（1字节）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;<span class="comment">//注意，这里会报错。因为两者相加超出了byte的表示范围。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure><p><strong>表达式中，byte，short，char是直接转换成int类型来参与运算的</strong>，<strong>因为怕超出表示范围，索性直接表示为int</strong>。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;与&amp;&amp;</p><p>|与||</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;：逻辑与 &amp;&amp;：短路与</span><br><span class="line">|：逻辑或 ||：短路或</span><br><span class="line">逻辑与和逻辑或两侧都要执行</span><br><span class="line">短路与和短路或在左侧可以确定结果时，不需要计算右边</span><br><span class="line">所以短路与和短路或的运算效率高于逻辑与和逻辑或</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>&gt;<span class="number">10</span> &amp;&amp; <span class="number">3</span>&gt;<span class="number">2</span> 左侧为<span class="literal">false</span>，右侧不执行</span><br></pre></td></tr></table></figure><h2 id="Java参数传递机制"><a href="#Java参数传递机制" class="headerlink" title="Java参数传递机制"></a>Java参数传递机制</h2><p>Java的参数传递机制都是<strong>值传递</strong>。</p><p>值传递：指的是在传输实参给方法的形参的时候，传输的其实是实参变量中存储的值的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     change(a);</span><br><span class="line">     System.out.println(<span class="string">&quot;final: &quot;</span>+ a);  <span class="comment">// 10</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before change: &quot;</span> + a); <span class="comment">//10</span></span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;after change: &quot;</span> + a); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
