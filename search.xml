<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>集合框架（二）</title>
      <link href="/posts/ffe0/"/>
      <url>/posts/ffe0/</url>
      
        <content type="html"><![CDATA[<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul><li>Map集合键是不允许重复的，但是值是可以重复的。</li><li>Map&lt;K,V&gt;<ul><li>HashMap&lt;K,V&gt; 无序，不重复，无索引<ul><li>LinkedHashMap&lt;K,V&gt; 有序、不重复、无索引</li></ul></li><li>TreeMap&lt;K,V&gt; 按键大小默认升序排序、不重复、无索引</li></ul></li><li>Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的。</li></ul><h2 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h2><ul><li>键找值：先获取Map集合全部的键，再通过遍历键来找值。</li><li>键值对：把“键值对”看成一个整体进行遍历。</li><li>Lambda：JDK8之后的新技术。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.键找值</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key:keys)&#123;</span><br><span class="line">    <span class="comment">//根据键获取对应的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.键值对</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; entry:entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Lambda</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String,String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String k,String v)</span>&#123;</span><br><span class="line">        sout(k+<span class="string">&quot;---&gt;&quot;</span>+v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((k,v) -&gt; sout(k+<span class="string">&quot;---&gt;&quot;</span>+v));</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap跟HashSet的底层原理是一摸一样的，都是基于哈希表实现的。</p><p>HashSet实际就是HashMap不要值数据而已。</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>有序、不重复、无索引。</p><p>底层数据结构还是基于哈希表来实现的，只是每个键值对又额外多了一个双链表的机制（头指针，尾指针）来记录元素顺序。</p><p>LinkedHashSet的底层就是依据LinkedHashMap来实现的。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap底层原理和TreeSet一致，都是基于红黑树实现。</p><h2 id="集合的嵌套"><a href="#集合的嵌套" class="headerlink" title="集合的嵌套"></a>集合的嵌套</h2><p>集合中的元素又是一个集合。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合框架</title>
      <link href="/posts/75dc/"/>
      <url>/posts/75dc/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h2><ul><li><strong>Collection</strong>（单列集合）<ul><li><strong>List</strong>：有序、可重复、有索引<ul><li>ArrayList</li><li>LinkedList</li></ul></li><li><strong>Set</strong>：无序、不重复、无索引<ul><li>HashSet<ul><li>LinkedHashSet：有序、不重复、无索引</li></ul></li><li>TreeSet：按照大小默认升序排序、不重复、无索引</li></ul></li></ul></li><li><strong>Map</strong>（双列集合）</li></ul><p>有序无序指的是：从集合中插入和取出元素的顺序是否一致。</p><h2 id="Collection常用方法"><a href="#Collection常用方法" class="headerlink" title="Collection常用方法"></a>Collection常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.添加元素</span></span><br><span class="line">add();</span><br><span class="line"><span class="comment">//2.清空集合</span></span><br><span class="line">clear();</span><br><span class="line"><span class="comment">//3.判断空</span></span><br><span class="line">isEmpty();</span><br><span class="line"><span class="comment">//4.集合大小</span></span><br><span class="line">size();</span><br><span class="line"><span class="comment">//5.包含</span></span><br><span class="line">contains(Object o);</span><br><span class="line"><span class="comment">//6.删除,默认删除重复元素的第一个</span></span><br><span class="line">remove(E e);</span><br><span class="line"><span class="comment">//7.集合转为数组</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//8.将一个集合的数据全部添加到另一个集合</span></span><br><span class="line">l1.addAll(List l2);</span><br></pre></td></tr></table></figure><h2 id="Collection的遍历方式"><a href="#Collection的遍历方式" class="headerlink" title="Collection的遍历方式"></a>Collection的遍历方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取迭代器对象</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> Iterator&lt;E&gt; list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">sout(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(元素数据类型 变量名：数组或者集合)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.forEach配合Lambda表达式</span></span><br><span class="line">c.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        sout(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">------ 简化 ------</span><br><span class="line">forEach(s -&gt; sout(s));</span><br></pre></td></tr></table></figure><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>List集合继承了Colection接口的所有方法，除此之外还具有包含索引的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="type">int</span> index,E ele);</span><br><span class="line">remove(<span class="type">int</span> index);</span><br><span class="line">get(<span class="type">int</span> index);</span><br><span class="line">set(<span class="type">int</span> index,E ele)</span><br></pre></td></tr></table></figure><h3 id="List遍历方式"><a href="#List遍历方式" class="headerlink" title="List遍历方式"></a>List遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.for循环</span></span><br><span class="line">list.fori;</span><br><span class="line"><span class="comment">//2.迭代器</span></span><br><span class="line">list.iterator();</span><br><span class="line"><span class="comment">//3.增强for</span></span><br><span class="line">list.<span class="keyword">for</span>;</span><br><span class="line"><span class="comment">//4.forEach配合lambda</span></span><br><span class="line">list.forEach(l -&gt; sout(l));</span><br></pre></td></tr></table></figure><h3 id="ArrayList集合的底层原理"><a href="#ArrayList集合的底层原理" class="headerlink" title="ArrayList集合的底层原理"></a>ArrayList集合的底层原理</h3><ul><li><strong>基于数组实现。</strong></li><li>查询速度快（根据索引查询快）</li><li>删除效率低（可能需要把后面的元素前移）</li><li>添加效率极低（可能需要把后面数据后移，再添加数据；还有可能需要进行数组扩容）</li></ul><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>​① 利用无参构造器创建的集合，会在底层创建一个默认长度为0的数组，用size来记录数组的大小。<br>​② 第一次添加元素的时候，底层会创建一个新的长度为10的数组。<br>​③ 存满时，会扩容1.5倍。（创建新数组，把原来的数据拷贝进来）。<br>​④ 如果一次添加的元素，1.5倍放不下，则新创建的数组长度以实际为准。</p><h4 id="ArrayList的应用场景"><a href="#ArrayList的应用场景" class="headerlink" title="ArrayList的应用场景"></a>ArrayList的应用场景</h4><ul><li>适合根据索引查询数据频繁的场景</li><li>适合数据量不是很大的场景</li><li>不适合数据量大又需要进行增删操作的场景。</li></ul><h3 id="LinkedList集合的底层原理"><a href="#LinkedList集合的底层原理" class="headerlink" title="LinkedList集合的底层原理"></a>LinkedList集合的底层原理</h3><ul><li><strong>基于双链表实现。</strong></li><li>查询慢，无论查询哪个数据都要从头开始查找。</li><li>增删相对快。</li></ul><p>LinkedList对首尾元素进行增删改查的速度是极快的。相比List多了很多针对首尾元素的特有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addFirst(E e);<span class="comment">//表头插入元素</span></span><br><span class="line">addLast(E e);<span class="comment">//表尾插入元素</span></span><br><span class="line">getFirst();<span class="comment">//获取表头元素</span></span><br><span class="line">getLast();<span class="comment">//获取表尾元素</span></span><br><span class="line">removeFirst();<span class="comment">//删除表头</span></span><br><span class="line">removeLast();<span class="comment">//删除表尾</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList应用场景"><a href="#LinkedList应用场景" class="headerlink" title="LinkedList应用场景"></a>LinkedList应用场景</h4><ul><li><p>用来设计队列，先进先出，后进后出（经常操作首尾数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.addLast();</span><br><span class="line">queue.removeFirst();</span><br></pre></td></tr></table></figure></li><li><p>用来设计栈，先进后出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.addFirst();</span><br><span class="line">stack.removeFirst();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序、不重复、无索引。</p><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul><li><p>就是一个int类型的数值，Java中每个对象都有哈希值。</p></li><li><p>Java中所有对象，都可以调用Object类提供的hashCode方法，返回该对象的哈希值。</p></li><li><p>不同对象哈希值不同，但也可能会相同（哈希碰撞）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h4><ul><li>基于哈希表实现。</li><li>哈希表是一种增删改查数据，性能都较好的数据结构。</li><li>JDK8之前，哈希表 &#x3D; 数组 + 链表</li><li>JDK8之后，哈希表 &#x3D; 数组 + 链表 + 红黑树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1，创建一个默认长度为16的数组，默认加载因子为0.75，数组名table</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 2，使用元素的哈希值对数组的长度求余计算元素应该存入数组中的位置</span></span><br><span class="line">set.add(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line"><span class="comment">// 3，判断存入位置是否为null，如果是null则直接存入</span></span><br><span class="line"><span class="comment">// 4，如果不为null，表示当前位置有元素，则调用equals方法比较</span></span><br><span class="line"><span class="comment">//4，1 比较相等的话，则不存</span></span><br><span class="line"><span class="comment">//4，2 比较不相等的话，则存入数组</span></span><br><span class="line"><span class="comment">//4，2，1 JDK8之前，新元素存入数组，占老元素位置，老元素挂在下面</span></span><br><span class="line"><span class="comment">//4，2，2 JDK8之后，新元素直接挂在老元素下面</span></span><br></pre></td></tr></table></figure><p><strong>如果数组快占满了，会出现什么问题？</strong></p><p>如果数组快占满了，数据可以沿着链表继续往下存，但是链表过长的话，会导致查询性能降低。</p><h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>当数组中的元素占据了长度16*加载因子0.75 &#x3D; 12个位置时，就会开始扩容，扩容为原来的两倍。但是还是会存在一种情况，某个位置的链表依然过长，JDK8之后规定，当链表长度超过8时，且数组长度&gt;&#x3D;64时，自动将链表转为红黑树。</p><h4 id="去重复机制"><a href="#去重复机制" class="headerlink" title="去重复机制"></a>去重复机制</h4><p>HashSet集合默认不能对内容一样的两个不同对象去重复！</p><p>如何让HashSet去重复？</p><p>如果希望Set集合认为两个内容一样的对象是重复的，必须重写对象的hashCode和equals方法，让内容一样的对象具备一样的hashCode，然后再使用equals比较。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>有序、不重复、无索引</p><h4 id="LinkedHashSet底层原理"><a href="#LinkedHashSet底层原理" class="headerlink" title="LinkedHashSet底层原理"></a>LinkedHashSet底层原理</h4><ul><li>基于哈希表实现（数组，链表，红黑树）实现的。</li><li>但是，它的每个元素都额外的多了一个双链表机制记录它前后元素的位置。（双链表来实现有序，指针多，内存换有序）</li></ul><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>可排序，不重复、无索引</p><p>底层使用红黑树实现排序。</p><h2 id="集合并发修改异常问题"><a href="#集合并发修改异常问题" class="headerlink" title="集合并发修改异常问题"></a>集合并发修改异常问题</h2><ul><li><p>使用迭代器遍历集合时，又同时在删除集合中的数据，程序就会出现并发修改异常的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.使用for循环删除[体育，体制，语文，数学，体验]中含有‘体’的字段</span></span><br><span class="line"><span class="comment">//[体育，体制，语文，数学，体验]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);<span class="comment">//[体制, 语文, 数学]</span></span><br><span class="line"><span class="comment">//这里体制没有被删掉，因为体育在被删掉的同时，体制会去到前一个位置，而索引还在往后加，因此直接略过体制字段。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何解决此问题？</span></span><br><span class="line"><span class="comment">//在每次删除元素时，需要让索引自减，即i--，或者倒着遍历删除元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">        i--; <span class="comment">//索引自减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);<span class="comment">//[语文, 数学]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用迭代器遍历元素的时候删除元素</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">    <span class="keyword">if</span> (str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)</span></span><br><span class="line"><span class="comment">at java.util.ArrayList$Itr.next(ArrayList.java:861)</span></span><br><span class="line"><span class="comment">at com.zhouquan.delete.Delete.main(Delete.java:27)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//会报并发修改异常。</span></span><br><span class="line"><span class="comment">//如何解决？</span></span><br><span class="line"><span class="comment">//使用迭代器自己的删除方法，不要使用集合的删除方法。</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">    <span class="keyword">if</span> (str.contains(<span class="string">&quot;体&quot;</span>))&#123;</span><br><span class="line">        it.remove(); <span class="comment">//使用迭代器自己的删除，删除当前遍历到的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Collections的其他相关知识"><a href="#Collections的其他相关知识" class="headerlink" title="Collections的其他相关知识"></a>Collections的其他相关知识</h2><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li>就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型…参数名称；</li><li>特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。</li><li>好处：常常用来灵活的接收数据。</li><li>注意：形参列表中，只能有一个可变形参，且必须放在列表的最后面。</li></ul><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>操作集合的工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addAll(Collection&lt;? <span class="built_in">super</span> T&gt; c, T...elements);<span class="comment">//为集合批量添加数据</span></span><br><span class="line">shuffle(List&lt;?&gt; list); <span class="comment">//打乱List集合的数据，类似洗牌</span></span><br><span class="line">sort(List&lt;?&gt; list); <span class="comment">//对List集合排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用API（二）</title>
      <link href="/posts/bcca/"/>
      <url>/posts/bcca/</url>
      
        <content type="html"><![CDATA[<h1 id="常用API（二）"><a href="#常用API（二）" class="headerlink" title="常用API（二）"></a>常用API（二）</h1><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>用于解决浮点型运算时，出现结果失真的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BigDecimal常见构造器、方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(<span class="type">double</span> d)</span>;<span class="comment">//禁止使用，还是存在精度的问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(String val)</span>; <span class="comment">//把String转成BigDecimal，底层用数组来存储每一位来运算。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将double值转包装成BigDecimal类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将BigDecimal转换成基础类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//加、减、乘、除</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">substract</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意除法</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(另一个数,精度几位,取舍模式)</span>;</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.1</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.3</span>);</span><br><span class="line">b1.divide(b2);<span class="comment">//这里会报错，因为无法整除，小数计算不知道保留几位</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> b1.divide(b2,<span class="number">2</span>,RoundingMode.HALF_UP);</span><br><span class="line">c.doubleValue();</span><br></pre></td></tr></table></figure><h2 id="日期、时间（JDK8之前）"><a href="#日期、时间（JDK8之前）" class="headerlink" title="日期、时间（JDK8之前）"></a>日期、时间（JDK8之前）</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>代表日期和时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>; <span class="comment">//创建一个Date对象，代表的是系统当前此刻日期时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>; <span class="comment">//把时间毫秒值转换成Date日期对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常见方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>; <span class="comment">//返回从1970年1月1日 0:0:0走到此刻的总毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>; <span class="comment">//设置日期对象的时间为当前时间毫秒值对应的时间</span></span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>将日期对象或者时间毫秒值格式化成想要的时间形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">(String pattern)</span>; <span class="comment">//创建简单日期格式化对象，并封装时间格式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss EEE a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日期对象或者时间毫秒值格式化成想要的时间形式。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span>; <span class="comment">//格式化日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Object time)</span>; <span class="comment">//格式化时间毫秒值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串时间转换成日期对象</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2022-12-22 12:12:11&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(dateStr);</span><br></pre></td></tr></table></figure><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>代表的是系统此刻时间对应的日历。</p><p>通过它可以单独获取、修改时间中的年、月、日、时、分、秒等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//获取当前日历对象</span></span><br><span class="line">now.get(Calendar.YEAR); <span class="comment">//获取日历中的某个信息</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> now.getTime();<span class="comment">//获取日期对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> now.getTimeMillis();<span class="comment">//获取时间毫秒值</span></span><br><span class="line">now.set(<span class="type">int</span> field,<span class="type">int</span> value);<span class="comment">//设置日历中某个信息</span></span><br></pre></td></tr></table></figure><h2 id="日期、时间（JDK8之后）"><a href="#日期、时间（JDK8之后）" class="headerlink" title="日期、时间（JDK8之后）"></a>日期、时间（JDK8之后）</h2><p>略</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印数组内容，字符串的形式拼接起来</span></span><br><span class="line">Arrays.toString(类型[] arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝数组</span></span><br><span class="line">Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">4</span>); <span class="comment">//范围包前不包后</span></span><br><span class="line">Arrays.copyOf(arr,<span class="number">10</span>);<span class="comment">// 拷贝数组，10比原数组大的话，相当于扩容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Arrays.sort(arr); <span class="comment">//默认升序排序</span></span><br></pre></td></tr></table></figure><p>如果sort中传入的数组比较复杂，Java不知道以何种规则进行比较，就需要手动定义规则。有两种方式：</p><ul><li><p>让该对象类实现Comparable接口，然后重写compareTo方法，自已定制比较规则。</p></li><li><p>使用下面的sort方法，创建Comparator比较器接口的匿名内部类对象，然后制定比较规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是JDK 8开始新增的一种语法形式；作用：用于简化匿名内部类的代码写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">(被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">    被重写方法的方法体代码。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：Lambda表达式只能简化函数式接口的匿名内部类</strong>。</p><p>函数式接口：1，接口  2，内部有且仅有1个抽象方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用API</title>
      <link href="/posts/c56f/"/>
      <url>/posts/c56f/</url>
      
        <content type="html"><![CDATA[<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的祖宗类。因此，Java中所有类的对象都可以直接使用Object类提供的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">//返回对象的字符串形式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>; <span class="comment">//判断两个对象是否相等，默认判断地址</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>; <span class="comment">//返回对象的副本</span></span><br></pre></td></tr></table></figure><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o1,Object o2)</span>; <span class="comment">// 更安全。先做非空判断，再比较两个对象，防止空指针异常bug。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Object obj)</span>;<span class="comment">// 判断对象是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">nonNull</span><span class="params">(Object o)</span>;<span class="comment">// 判断对象是否不为空</span></span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类就是将基本数据类型封装成对象。</p><p>泛型和集合的使用是不支持基本数据类型的，因此需要包装类来支撑。</p><p>自动装箱机制：可以自动将基本数据类型转换为对象。</p><p>自动拆箱机制：可以自动将包装类型数据转换为对应的基本数据类型。</p><ul><li><p>Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="type">int</span>); <span class="comment">//基本数据类型转换为包装类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> i;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="包装类的其他操作"><a href="#包装类的其他操作" class="headerlink" title="包装类的其他操作"></a>包装类的其他操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.把基本类型的数据转换成字符串</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">a_s</span> <span class="operator">=</span> Integer.toString(a); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.把字符串类型的数据转换为对应的基本类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;23&quot;</span>);</span><br><span class="line"><span class="type">double</span> = Double.parseDouble(<span class="string">&quot;23.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Integer.valueOf(<span class="string">&quot;23&quot;</span>);</span><br><span class="line">Double.valueOf(<span class="string">&quot;23.1&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>String对象是不可变的。</strong></p><p><strong>双引号创建的字符串对象，存储在堆内存的字符串常量池中，且相同内容的字符串只存储一份。</strong></p><p><strong>new关键字创建出来的字符串对象，每次new都会产生一个新的对象存储在堆内存中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">sout(s1 == s2); <span class="comment">// true 比较地址，相同内容只存储一份</span></span><br><span class="line">    </span><br><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">sout(s1 == s2); <span class="comment">// false new创建的对象都是新的对象，地址不一样</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//面试题1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 此行代码创建了2个对象，一个是“abc”存储在字符串常量池，一个是new关键字创建的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 此行代码创建了0个对象，因为直接使用的是字符串常量池的“abc”</span></span><br><span class="line">sout(s1 == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;c&quot;</span>; <span class="comment">// 字符串变量运算会在堆内存中创建新对象 </span></span><br><span class="line">sout(s1 == s3); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题3</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>; <span class="comment">// 确定的常量，编译器会在编译时，直接将&quot;a&quot; + &quot;b&quot; + &quot;c&quot;转成&quot;abc&quot;,以提高程序的性能。</span></span><br><span class="line">sout(s1 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><p>StringBuilder代表可变字符串对象，相当于一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。</p><p>好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁。</p><p>StringBuilder是线程不安全的，StringBuffer是线程安全的。</p><h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringJoiner拼接字符串</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span> ,<span class="string">&quot;]&quot;</span>); <span class="comment">//分隔符,开始符号，结束符号</span></span><br><span class="line">s.add(<span class="string">&quot;java1&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;java2&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;java3&quot;</span>);</span><br><span class="line">sout(s);<span class="comment">// [java1, java2, java3]</span></span><br></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>代表数学，是一个工具类，里面提供的都是对数据进行操作的一些静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span>; <span class="comment">//获取绝对值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//向上取整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//向下取整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">round</span><span class="params">(<span class="type">float</span> a)</span>; <span class="comment">//四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span>; <span class="comment">//获取两个int值中的较大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>; <span class="comment">//返回a的b次幂的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span>; <span class="comment">//返回值为double的随机值，范围[0.0,1.0)</span></span><br></pre></td></tr></table></figure><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>System代表程序所在的系统，也是一个工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>; <span class="comment">//终止当前运行的Java虚拟机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>; <span class="comment">//返回当前系统的时间毫秒值形式，指从1970-1-1 0:0:0 开始到此刻的毫秒值。可以用来统计某段程序运行时间。</span></span><br></pre></td></tr></table></figure><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>Runtime代表程序所在的运行环境，Runtime是一个单例类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">r.exit(<span class="type">int</span>); <span class="comment">//非0状态码表示异常终止</span></span><br><span class="line">r.availableProcessors();<span class="comment">//获取虚拟机能够使用的处理器数</span></span><br><span class="line">r.totalMemory();<span class="comment">//返回Java虚拟机中的内存总量</span></span><br><span class="line">r.freeMemory();<span class="comment">//返回Java虚拟机中的可用内存量</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> r.exec(String command);<span class="comment">//启动某个程序，并返回代表该程序的对象</span></span><br><span class="line">Thread。sleep(<span class="number">5000</span>);<span class="comment">//程序停5秒</span></span><br><span class="line">p.destroy()<span class="comment">//销毁程序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象（二）</title>
      <link href="/posts/c2dd/"/>
      <url>/posts/c2dd/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象（二）"><a href="#Java面向对象（二）" class="headerlink" title="Java面向对象（二）"></a>Java面向对象（二）</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>如果一个类定义在另一个类的内部，那么这个类就是内部类。</p><p>场景：当一个类的内部，包含了一个完成的事物，且这个事物没有必要单独设计时，就可以把这个事物设计为内部类。</p><ul><li><p>成员内部类：类中的一个普通成员，类似于成员变量。可以访问外部内中的任何成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outet.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">Outer.<span class="built_in">this</span> <span class="comment">//拿到外部类对象</span></span><br></pre></td></tr></table></figure></li><li><p>静态内部类：有static修饰的内部类，属于外部类自己持有。只能访问外部类的静态成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure></li><li><p>局部内部类：局部内部类是定义在方法中、代码块中、构造器等执行体中的类。</p></li><li><p><strong>匿名内部类</strong>：特殊的局部内部类，不需要为其声明名字。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名内部类书写格式，会将其编译成一个子类，然后立即创建一个子类对象出来。</span></span><br><span class="line"><span class="type">Anaimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;喵喵喵~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象。</span><br><span class="line">作用：用于更方便的创建一个子类对象。</span><br></pre></td></tr></table></figure></li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是一种特殊类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法</span></span><br><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    名称<span class="number">1</span>,名称<span class="number">2</span>,...;</span><br><span class="line">    其他成员...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X,Y,Z;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;A.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;A&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">X</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">A</span> <span class="variable">Z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A[] values();<span class="comment">// 拿到全部对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>; <span class="comment">//根据名字得到对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类本身的一个对象。</li><li>枚举类的构造器都是私有的，因此不可以创建对象。</li><li>枚举都是最终类，不可以被继承。</li><li>枚举类中，从第二行开始可以定义类的其他各种成员。</li></ul><h3 id="枚举实现单例模式"><a href="#枚举实现单例模式" class="headerlink" title="枚举实现单例模式"></a>枚举实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X; <span class="comment">//单例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举应用场景"><a href="#枚举应用场景" class="headerlink" title="枚举应用场景"></a>枚举应用场景</h3><p>用来表示一组信息，然后作为参数传输。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>定义类、接口、方法时，同时声明了一个或者多个类型变量<E>，称为泛型类、泛型接口、泛型方法。</p><p>作用：做类型限定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Car</span>&gt; <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(ArrayList&lt;T&gt; cars)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? 通配符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(ArrayList&lt;? extends Car&gt; cars)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的擦除问题和注意事项"><a href="#泛型的擦除问题和注意事项" class="headerlink" title="泛型的擦除问题和注意事项"></a>泛型的擦除问题和注意事项</h3><ul><li>泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。还是对类型进行强转。</li><li>泛型不支持基本数据类型，只能支持对象类型（引用数据类型）。</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常就是代表程序出现的问题。</p><p>如：数组越界，除零等。</p><p>Throwable</p><ul><li>Error</li><li>Exception<ul><li>RuntimeException：编译时不会出现错误提醒，运行时出现异常。</li><li>其他异常</li></ul></li></ul><p>处理异常：</p><ul><li>在方法上使用throws关键字，可以将方法内部出现的异常抛出去交给调用者处理。</li><li>捕获异常（try…catch代码块）</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li><p>自定义运行时异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个异常类继承RuntimeException</span></span><br><span class="line"><span class="comment">//2.重写构造器</span></span><br><span class="line"><span class="comment">//3.通过throw new 异常类()来创建异常对象并抛出。</span></span><br><span class="line"></span><br><span class="line">编译时不报错</span><br></pre></td></tr></table></figure></li><li><p>自定义编译时异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义一个异常类继承Exception</span></span><br><span class="line"><span class="comment">//2.重写构造器</span></span><br><span class="line"><span class="comment">//3.通过throw new 异常类()来创建异常对象并抛出。</span></span><br><span class="line"></span><br><span class="line">编译阶段就报错，表示问题严重，需要在代码里强烈提醒！！！</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/posts/70b0/"/>
      <url>/posts/70b0/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this就是一个变量，可以用在方法中，<strong>来拿到当前对象</strong>。</p><p>this主要用来解决变量名称冲突的问题，当方法内部变量名与成员变量名一致时，使用this.成员变量名与之进行区分。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li>类在设计时，如果不写构造器，Java会为类生成一个无参的构造器。</li><li>一旦定义了有参的构造器，Java就不会帮助类生成无参构造器，此时建议手写一个无参构造器出来。</li><li>构造器用于完成对象的初始化（对成员变量进行初始化赋值）。</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>什么是封装？</p><p>封装是将数据和对数据进行操作的函数绑定到一起的机制，它将对象的数据和方法结合到一起，隐藏内部实现的细节。封装的目的是提高数据的安全性和可维护性。</p><p>封装的设计规范：合理隐藏，合理暴露。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><table><thead><tr><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>类中的位置不同</td><td>类中，方法外</td><td>常见于方法</td></tr><tr><td>初始值不同</td><td>有默认值，不需要初始化赋值</td><td>没有默认值，使用前必须先赋值</td></tr><tr><td>内存位置不同</td><td>堆内存</td><td>栈内存</td></tr><tr><td>作用域不同</td><td>整个对象</td><td>在所归属的括号内</td></tr><tr><td>生命周期不同</td><td>与对象共存亡</td><td>随着方法的调用而生，方法的运行结束而亡</td></tr></tbody></table><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>静态，可以修饰成员变量、成员方法。</p><p>成员变量按照有无static关键字修饰，可以分为两种：</p><ul><li>类变量，在内存中只存在一份，与类一起加载，被所有对象共享。</li><li>实例变量（对象的变量）</li></ul><p>成员方法按照有无static关键字修饰，可以分为：</p><ul><li>类方法</li><li>实例方法</li></ul><p><strong>注意事项</strong></p><ul><li>类方法中可以直接访问类成员，不可以直接访问实例成员。</li><li>实例方法中可以直接访问类成员，也可以直接访问实例成员</li><li>实例方法中可以出现this关键字，类方法中不可以出现this关键字</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块分为两种：</p><ul><li>静态代码块<ul><li>格式：static{}</li><li>特点：类加载时自动执行，由于类只加载一次，所以静态代码块也只执行一次。</li><li>作用：完成类的初始化，例如：对类变量的初始化赋值</li></ul></li><li>实例代码块<ul><li>格式：{}</li><li>特点：每次创建对象时，执行实例代码块，并在构造器之前执行。</li><li>作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值。</li></ul></li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul><li><p>确保一个类只有一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.饿汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.内部自己创建一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供给外部使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.懒汉式单例模式（延时加载）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//2.类变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.私有构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供外部使用,调用时才创建单例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span>)&#123;</span><br><span class="line">            a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h3><p>Java中提供了一个关键字extends，可以让一个类和另一个类建立起父子关系。</p><ul><li>子类能继承父类的非私有成员（成员变量，成员方法）</li><li>子类对象是由子类、父类共同完成的。</li><li>继承可以减少重复代码的编写。</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>权限修饰符：用来限制类中成员能够被访问的范围。</p><p>权限等级：private &lt; 缺省 &lt; protected &lt; public。</p><table><thead><tr><th>修饰符</th><th>在本类中</th><th>同一包下其他类中</th><th>任意包下的子类</th><th>任意包下的任意类里</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>缺省</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>Java中的类不支持多继承，但是支持多层继承。</p><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>什么是方法重写？</p><ul><li>当子类觉得父类中某个方法不好用，或者无法满足自己的需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的方法，这就是方法重写。</li><li>重写后，方法的访问，Java遵循就近原则。</li></ul><p>注意事项：</p><ul><li>子类重写父类方法时，访问权限必须大于或等于父类该方法的权限。</li><li>重写方法的返回值类型必须与被重写方法的返回值类型一样，或者范围更小。</li><li>私有方法、静态方法不能被重写（静态方法在编译时已经与类进行了绑定，不依赖于类的实例，而是通过类名直接访问。当子类存在一个与父类静态方法相同的方法时，子类的静态方法实际会隐藏父类的静态方法，而不是进行重写。）。</li></ul><p>子类的全部构造器，都会先调用父类的构造器，再执行自己的代码。</p><ul><li>默认情况下，子类全部构造器的第一行代码都是super()，它会调用父类的无参数构造器。</li><li>如果父类没有无参数构造器，则我们必须在子类构造器的第一行手写super(…)，指定去调用父类的有参数构造器。</li></ul><p><strong>子类构造器为什么要调用父类的构造器？</strong></p><p>子类中继承了父类的部分成员，这部分成员的初始化可以通过调用父类的构造器来实现，然后再初始化子类的特有成员。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是在继承&#x2F;实现情况下的一种现象，表现为：对象多态、行为多态。</p><p>如：父类引用指向子类对象。</p><p><strong>特别注意：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//People是Teacher的父类</span></span><br><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">p1.run(); <span class="comment">//对于方法，编译看左边，运行看右边 //执行Teacher中的run方法</span></span><br><span class="line">sout(p1.name); <span class="comment">//对于变量，编译看左边，运行也看左边  //输出父类中name属性</span></span><br></pre></td></tr></table></figure><p>多态的好处：</p><ul><li>多态形式下，右边对象是解耦合的，更便于扩展和维护。</li><li>定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利。</li></ul><p>多态的问题：</p><ul><li>父类引用指向子类对象，无法直接调用子类的特有方法。（无法过编译，编译看左边）</li><li>解决这一问题，需要对父类引用进行强制类型转换，转换为子类对象。（转换前使用instanceof判断真实类型）</li></ul><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final关键字是最终的意思，可以修饰（类，方法，变量）。</p><ul><li>修饰类：该类被称为最终类，无法被继承</li><li>修饰方法：该方法被称为最终方法，无法被重写</li><li>修饰变量：该变量只能被赋值一次，之后不允许改变</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>使用了static final修饰的成员变量被称为常量。</p><p>作用：通常用于记录系统中的配置信息。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract关键字修饰类，这个类就是抽象类。</p><p>abstract修饰方法，称为抽象方法，抽象方法不能有方法体。</p><p>抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。它有构造函数，用于子类对象的初始化调用。</p><p><strong>抽象类的好处</strong>：每个子类的行为不同，因此将父类的方法定义为抽象方法，交给不同的子类去重写实现，可以更好地支持多态。</p><p><strong>应用场景：</strong>经常被用来设计模板方法设计模式。</p><h2 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h2><p>解决方法中存在重复代码的问题。</p><p>写法：</p><ul><li>1、定义一个抽象类</li><li>2、在里面定义2个方法<ul><li>一个是模板方法：把相同的代码放进去，建议用final关键字修饰模板方法。</li><li>一个是抽象方法：具体实现交给子类来完成。</li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java提供了关键字interface，用这个关键字可以定义一个特殊的结构：接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量（常量）</span></span><br><span class="line">    <span class="comment">//成员方法（抽象方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的好处：</p><ul><li>弥补了类单继承的不足，一个类可以实现多个接口，扩展更多的功能。</li><li>让程序可以面向接口编程，这样程序员就可以灵活方便地切换各种业务实现。</li></ul><p>JDK8之后接口新特性：接口中新增3种方法，方法可以写方法体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//1.默认方法，使用default修饰</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.私有方法，必须使用private修饰</span></span><br><span class="line">    priavate <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.类方法（静态方法）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要添加这些新方法？</p><ul><li>增强了接口的能力，更便于项目的扩展和维护。（要扩展新功能，只需要在接口中定义上述带方法体的方法，而不需要让实现类都来进行实现了）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/posts/981f/"/>
      <url>/posts/981f/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="JDK的组成"><a href="#JDK的组成" class="headerlink" title="JDK的组成"></a>JDK的组成</h2><p><strong>JVM</strong>：java虚拟机，运行Java程序的地方。</p><p><strong>核心类库</strong>：Java内部程序，可供程序员调用。</p><p><strong>JRE</strong>：Java运行环境，包含上述。</p><p><strong>JDK</strong>：Java开发工具包，包含上述。</p><h2 id="Java跨平台特性"><a href="#Java跨平台特性" class="headerlink" title="Java跨平台特性"></a>Java跨平台特性</h2><p><strong>一次编译，处处可用</strong></p><p>Java编译工具<code>javac</code>将源文件编译为字节码文件，不同的平台只需要安装对应的JVM就可以对字节码文件进行执行了。</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>字符在计算中怎么存的？</p><p>字符在ASCII码表中有对应的数字编号表示，计算机存储对应的二进制形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syso(<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>); <span class="comment">//97+10 输出107</span></span><br><span class="line">syso(<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>); <span class="comment">//65+10 输出75</span></span><br><span class="line">syso(<span class="string">&#x27;0&#x27;</span>+<span class="number">10</span>); <span class="comment">//48+10 输出58    </span></span><br></pre></td></tr></table></figure><h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><p>Java中支持书写二进制、八进制、十六进制的数据，分别用0B、0、0x开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0B01100001</span>;<span class="comment">//二进制数</span></span><br><span class="line">syso(a); <span class="comment">//输出97</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0141</span>; <span class="comment">//八进制数</span></span><br><span class="line">syso(a); <span class="comment">//输出97</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x61</span>;<span class="comment">//十六进制</span></span><br><span class="line">syso(a); <span class="comment">//输出97</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>基本数据类型：</strong>4大类8种</p><p><strong>整型</strong>：<code>byte（1字节，-128~127）</code>、<code>short（2字节）</code>、<code>int（4字节）</code>、<code>long（8字节）</code></p><p><strong>浮点型</strong>：<code>float（4字节）</code>、<code>double（8字节）</code></p><p><strong>字符型：</strong><code>char(2字节)</code></p><p><strong>布尔型</strong>：<code>boolean（1字节）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;<span class="comment">//注意，这里会报错。因为两者相加超出了byte的表示范围。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;<span class="comment">//正确写法</span></span><br></pre></td></tr></table></figure><p><strong>表达式中，byte，short，char是直接转换成int类型来参与运算的</strong>，<strong>因为怕超出表示范围，索性直接表示为int</strong>。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;与&amp;&amp;</p><p>|与||</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;：逻辑与 &amp;&amp;：短路与</span><br><span class="line">|：逻辑或 ||：短路或</span><br><span class="line">逻辑与和逻辑或两侧都要执行</span><br><span class="line">短路与和短路或在左侧可以确定结果时，不需要计算右边</span><br><span class="line">所以短路与和短路或的运算效率高于逻辑与和逻辑或</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>&gt;<span class="number">10</span> &amp;&amp; <span class="number">3</span>&gt;<span class="number">2</span> 左侧为<span class="literal">false</span>，右侧不执行</span><br></pre></td></tr></table></figure><h2 id="Java参数传递机制"><a href="#Java参数传递机制" class="headerlink" title="Java参数传递机制"></a>Java参数传递机制</h2><p>Java的参数传递机制都是<strong>值传递</strong>。</p><p>值传递：指的是在传输实参给方法的形参的时候，传输的其实是实参变量中存储的值的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">     change(a);</span><br><span class="line">     System.out.println(<span class="string">&quot;final: &quot;</span>+ a);  <span class="comment">// 10</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before change: &quot;</span> + a); <span class="comment">//10</span></span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;after change: &quot;</span> + a); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
